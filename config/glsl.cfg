// standard shader definitions

lazyshader = [
    defershader $arg1 $arg2 [
        shader @arg1 @arg2 [@@arg3] [@@arg4]
    ]
]

ginterpvert = [
    if (|| $gdepthformat $arg1) [result [
        uniform vec2 lineardepthscale;
        uniform vec3 gdepthpackparams;
        varying float lineardepth;
    ]]
]
msaainterpvert = [ginterpvert $msaasamples]

ginterpfrag = [
    result [
        fragdata(0, gcolor, vec4)
        fragdata(1, gnormal, vec4)
        fragdata(2, gglow, vec4)
        @(? $gdepthformat [fragdata(3, gdepth, vec4)])
        @(? (|| $gdepthformat $arg1) [
            uniform vec2 lineardepthscale;
            uniform vec3 gdepthpackparams;
            varying float lineardepth;
        ])
    ]
]
msaainterpfrag = [ginterpfrag $msaasamples]

gdepthpackvert = [
    if (|| $gdepthformat $arg1) [result [
        lineardepth = dot(lineardepthscale, gl_Position.zw);
    ]]
]
msaapackvert = [gdepthpackvert $msaasamples]

gpackdepth = [
    result [
        vec3 @arg1 = @arg2 * gdepthpackparams;
        @arg1 = vec3(@arg1.x, fract(@arg1.yz));
        @arg1.xy -= @arg1.yz * (1.0/255.0);
    ]
]

ghashdepth = [
    if $arg3 [
        arg1 = [(@arg1 + 5.0*@arg3)]
    ] 
    if $arg2 [result [
        @arg2*0.76 + mix(0.75, 0.25, @arg2)*fract(@arg1*mix(-1.0/192.0, -1.0/64.0, @arg2))
    ]] [result [
        0.75*fract(@arg1*(-1.0/192.0))
    ]]
]
        
gdepthpackfrag = [
    if (= $gdepthformat 1) [result [
        @(gpackdepth packdepth lineardepth)
        gdepth.rgb = packdepth;
        gdepth.a = @(? $arg2 $arg2 [0.0]);
        gnormal.a = @(if $arg1 [ghashdepth lineardepth "" $arg3] [result [0.0]]);
    ]] [result [
        @(? (> $gdepthformat 1) [
            gdepth.r = lineardepth;
        ])
        gnormal.a = @(if $arg1 [ghashdepth lineardepth $arg2 $arg3] [? $arg2 $arg2 [0.0]]);
    ]]
]
msaapackfrag = [gdepthpackfrag $msaasamples $arg1 $arg2]

gdepthunpackparams = [
    result [
        uniform vec3 gdepthscale;
        uniform vec3 gdepthunpackparams;
    ]
]

gdepthunpack = [
    if $arg6 [
        if $arg7 [result [
            vec3 @[arg7] = @[arg2].rgb;
            float @[arg1] = dot(@[arg7], gdepthunpackparams); 
            @arg3
        ]] [result [
            float @[arg1] = dot(@[arg2].rgb, gdepthunpackparams); 
            @arg3
        ]]
    ] [if (|| $gdepthformat $arg5) [
        if (|| (> $gdepthformat 1) $arg5) [result [
            float @[arg1] = @[arg2].r;
            @arg3
        ]] [result [
            float @[arg1] = dot(@[arg2].rgb, gdepthunpackparams); 
            @arg3
        ]]
    ] [if (=s $arg4 []) [result [
        float @[arg1] = gdepthscale.x / (@[arg2].r*gdepthscale.y + gdepthscale.z);
    ]] [result [
        float @[arg1] = @[arg2].r;
        @arg4
    ]]]]
]

gfetchdefs = [
    gfetchprefix = (? $arg3 $arg3 "gfetch")
    if (? (>= $numargs 2) $arg2 $msaasamples) [result [
        uniform sampler2DMS @(prettylist $arg1);
        #define @[gfetchprefix]sample 0
        #define @[gfetchprefix](sampler, coords) texelFetch(sampler, ivec2(coords), @[gfetchprefix]sample)
        #define @[gfetchprefix]offset(sampler, coords, offset) texelFetch(sampler, ivec2(coords) + offset, @[gfetchprefix]sample)
        #define @[gfetchprefix]proj(sampler, coords) texelFetch(sampler, ivec2(coords.xy / coords.z), @[gfetchprefix]sample)
        #if __VERSION__ >= 130 || defined(GL_EXT_gpu_shader4)
            #define @[gfetchprefix]clamp(sampler, coords) texelFetch(sampler, clamp(ivec2(coords), ivec2(0), textureSize(sampler)-1), @[gfetchprefix]sample)
        #else
            #define @[gfetchprefix]clamp(sampler, coords) texelFetch(sampler, ivec2(clamp(coords, vec2(0.0), vec2(textureSize(sampler)-1))), @[gfetchprefix]sample)
        #endif
        @(if (! $arg3) [gdepthunpackparams])
    ]] [result [
        uniform sampler2DRect @(prettylist $arg1);
        #define @[gfetchprefix](sampler, coords) texture2DRect(sampler, coords)
        #define @[gfetchprefix]offset(sampler, coords, offset) texture2DRectOffset(sampler, coords, offset)
        #define @[gfetchprefix]proj(sampler, coords) texture2DRectProj(sampler, coords)
        #define @[gfetchprefix]clamp(sampler, coords) texture2DRect(sampler, coords)
        @(if (! $arg3) [gdepthunpackparams])
    ]]
]

shader 0 "null" [
    attribute vec4 vvertex;
    void main(void)
    {
        gl_Position = vvertex;
    }
] [
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = vec4(1.0, 0.0, 1.0, 1.0);
    }
]

///////////////////////////////////////////////////
//
// used for rendering to the HUD
//
///////////////////////////////////////////////////

shader 0 "hud" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0; 
        colorscale = vcolor;
    }
] [
    uniform sampler2D tex0;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec4 color = texture2D(tex0, texcoord0);
        #pragma CUBE2_swizzle color
        fragcolor = colorscale * color;
    }
]

shader 0 "hudtext" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0; 
        colorscale = vcolor;
    }
] [
    uniform sampler2D tex0;
    uniform vec4 textparams;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        float dist = texture2D(tex0, texcoord0).r;
        float border = smoothstep(textparams.x, textparams.y, dist);
        float outline = smoothstep(textparams.z, textparams.w, dist);
        fragcolor = vec4(colorscale.rgb * outline, colorscale.a * border);
    }
]

shader 0 "hudrgb" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0; 
        colorscale = vcolor;
    }
] [
    uniform sampler2D tex0;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec4 color = texture2D(tex0, texcoord0);
        #pragma CUBE2_swizzle color
        fragcolor.rgb = colorscale.rgb * color.rgb;
        fragcolor.a   = colorscale.a;
    }
]

shader 0 "hudnotexture" [
    attribute vec4 vvertex, vcolor;
    uniform mat4 hudmatrix;
    varying vec4 color;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        color = vcolor;
    }
] [
    varying vec4 color;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = color;
    }
]

shader 0 "hudrect" [ 
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0; 
        colorscale = vcolor;
    }
] [
    uniform sampler2DRect tex0;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = colorscale * texture2DRect(tex0, texcoord0);
    }
]

shader 0 "hud3d" [
    attribute vec4 vvertex, vcolor;
    attribute vec3 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec3 texcoord0;
    varying vec4 color;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0;
        color = vcolor;
    }
] [
    uniform sampler3D tex0;
    varying vec3 texcoord0;
    varying vec4 color;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = color * texture3D(tex0, texcoord0);
    }
]

shader 0 "hudcubemap" [ 
    attribute vec4 vvertex, vcolor;
    attribute vec3 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec3 texcoord0;
    varying vec4 colorscale;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0;
        colorscale = vcolor;
    }
] [
    uniform samplerCube tex0;
    varying vec3 texcoord0;
    varying vec4 colorscale;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = colorscale * textureCube(tex0, texcoord0);
    }
]

//////////////////////////////////////////////////////////////////////
//
// fogged variants of default shaders
//
//////////////////////////////////////////////////////////////////////

shader 0 "fogged" [
    #pragma CUBE2_fog
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 camprojmatrix;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        texcoord0 = vtexcoord0; 
        colorscale = vcolor;
    }
] [
    uniform sampler2D tex0;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec4 color = texture2D(tex0, texcoord0);
        #pragma CUBE2_swizzle color
        fragcolor = colorscale * color;
    }
]

shader 0 "foggednotexture" [
    #pragma CUBE2_fog
    attribute vec4 vvertex, vcolor;
    uniform mat4 camprojmatrix;
    varying vec4 color;
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        color = vcolor;
    }
] [
    varying vec4 color;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = color;
    }
]

//////////////////////////////////////////////////////////////////////
//
// LDR variants of default shaders
//
//////////////////////////////////////////////////////////////////////

shader 0 "ldr" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 camprojmatrix;
    uniform float ldrscale;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        texcoord0 = vtexcoord0; 
        colorscale = vec4(ldrscale * vcolor.rgb, vcolor.a);
    }
] [
    uniform sampler2D tex0;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec4 color = texture2D(tex0, texcoord0);
        #pragma CUBE2_swizzle color
        fragcolor = colorscale * color;
    }
]

shader 0 "ldrnotexture" [
    attribute vec4 vvertex, vcolor;
    uniform mat4 camprojmatrix;
    uniform float ldrscale;
    varying vec4 color;
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        color = vec4(ldrscale * vcolor.rgb, vcolor.a);
    }
] [
    varying vec4 color;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = color;
    }
]

//////////////////////////////////////////////////////////////////////
//
// for filling the z-buffer only (i.e. multi-pass rendering, OQ)
//
//////////////////////////////////////////////////////////////////////

shader 0 "nocolor" [
    attribute vec4 vvertex;
    uniform mat4 camprojmatrix;
    void main() { gl_Position = camprojmatrix * vvertex; } 
] [
    void main() {}
]

////////////////////////////////////////////////////////
//
// world shaders
//
///////////////////////////////////////////////////////

// worldtype:
//    e -> reserve envmap texture slot
//    r -> envmap reflection
//    g -> glow
//    G -> pulse glow
//    b -> blendmap
//    a -> refractive
//    T -> triplanar
//    d -> decal

wtopt = [ >= (strstr $worldtype $arg1) 0 ]

worldvariantshader = [
    worldtype = $arg2
    stype = (? (wtopt "e") 3 1)
    srow = -1
    if (wtopt "G") [
        stype = (+ $stype 0x10)
        defuniformparam "glowcolor" 1 1 1 // glow color
        defuniformparam "pulseglowspeed" 1     // pulse frequency (Hz)
        defuniformparam "pulseglowcolor" 0 0 0 // pulse glow color
    ] [if (wtopt "g") [
        defuniformparam "glowcolor" 1 1 1  // glow color
    ]]
    if (wtopt "r") [
        defuniformparam "envscale" 0.2 0.2 0.2 // reflectivity 
    ]
    if (wtopt "T") [
        defuniformparam "triplanarbias" 0.3 0.3 0.3
        stype = (+ $stype 0x20)
    ]
    if (wtopt "b") [
        srow = 0
    ]
    if (wtopt "a") [
        stype = (+ $stype 4)
        srow = 1
    ]
    variantshader $stype $arg1 $srow [
        attribute vec4 vvertex;
        attribute vec3 vnormal;
        attribute vec2 vtexcoord0;
        uniform mat4 camprojmatrix;
        uniform vec2 texgenscroll;
        varying vec3 normal;
        @(msaainterpvert)
        @(if (wtopt "T") [result [
            uniform vec2 texgenscale;
            varying vec2 texcoordx, texcoordy, texcoordz;
            @(? (wtopt "d") [uniform vec2 decalscale;])
        ]] [result [
            varying vec2 texcoord0;
        ]])
        @(? (wtopt "d") [
            uniform vec2 decalscale;
        ]) 
        @(? (wtopt "r") [uniform vec3 camera; varying vec3 camvec;])
        @(? (wtopt "G") [uniform float millis; varying float pulse;])
        @(? (wtopt "b") [
            uniform vec4 blendmapparams;
            varying vec2 texcoord1;
        ])

        void main(void)
        {
            gl_Position = camprojmatrix * vvertex;
            @(if (wtopt "T") [result [
                texcoordx = vec2(vvertex.y, -vvertex.z) * texgenscale;
                texcoordy = vec2(vvertex.x, -vvertex.z) * texgenscale;
                texcoordz = vvertex.xy * @(? (wtopt "d") "decalscale" "texgenscale");
            ]] [result [
                texcoord0 = vtexcoord0 + texgenscroll;
            ]])
            @(? (wtopt "b") [
                texcoord1 = (vvertex.xy - blendmapparams.xy)*blendmapparams.zw;
            ])
            normal = vnormal;
    
            @(msaapackvert)

            @(? (wtopt "r") [camvec = camera - vvertex.xyz;])

            @(? (wtopt "G") [
                pulse = abs(fract(millis*pulseglowspeed.x)*2.0 - 1.0);
            ])
        }
    ] [
        @(if (wtopt "a") [result [
            @(gfetchdefs refractlight)
            uniform vec4 refractparams;
        ]])
        uniform vec4 colorparams;
        uniform sampler2D diffusemap;
        @(? $msaasamples [uniform float hashid;])
        varying vec3 normal;
        @(msaainterpfrag)
        @(if (wtopt "T") [result [
            varying vec2 texcoordx, texcoordy, texcoordz;
            @(? (wtopt "d") [uniform sampler2D decaldiffusemap;])
        ]] [result [
            varying vec2 texcoord0;
        ]])
        @(? (wtopt "g") [uniform sampler2D glowmap;])
        @(? (wtopt "G") [varying float pulse;])
        @(? (wtopt "r") [uniform samplerCube envmap; varying vec3 camvec;])
        @(? (wtopt "b") [
            uniform float blendlayer;
            uniform sampler2D blendmap;
            varying vec2 texcoord1;
        ])

        void main(void)
        {
            @(if (wtopt "T") [result [
                vec3 triblend = max(abs(normal) - triplanarbias.xyz, 0.001);
                triblend *= triblend;
                triblend /= triblend.x + triblend.y + triblend.z;

                vec4 diffusex = texture2D(diffusemap, texcoordx);   
                vec4 diffusey = texture2D(diffusemap, texcoordy);   
                vec4 diffusez = texture2D(@(? (wtopt "d") "decaldiffusemap" "diffusemap"), texcoordz);   
                vec4 diffuse = diffusex*triblend.x + diffusey*triblend.y + diffusez*triblend.z;
            ]] [result [
                vec4 diffuse = texture2D(diffusemap, texcoord0);   
            ]])

            gcolor.rgb = diffuse.rgb*colorparams.rgb;
            gcolor.a = 0.0;
            gnormal.rgb = normal*0.5+0.5;

            @(if (wtopt "g") [result [
                @(? (wtopt "T") [
                    vec3 glowx = texture2D(glowmap, texcoordx).rgb;   
                    vec3 glowy = texture2D(glowmap, texcoordy).rgb;   
                    vec3 glowz = texture2D(glowmap, texcoordz).rgb;   
                    vec3 glow = glowx*triblend.x + glowy*triblend.y + glowz*triblend.z;
                ] [
                    vec3 glow = texture2D(glowmap, texcoord0).rgb;
                ])
                @(if (wtopt "G") [result [
                    vec3 pulsecol = mix(glowcolor.xyz, pulseglowcolor.xyz, pulse);
                ]])
                glow *= @(? (wtopt "G") "pulsecol" "glowcolor.xyz"); 
                gglow.rgb = glow;
            ]] [result [
                gglow.rgb = vec3(0.0);
            ]])

            @(? (wtopt "r") [
                vec3 reflect = textureCube(envmap, 2.0*normal*dot(camvec, normal) - camvec).rgb;
                gcolor.rgb *= 1.0 - envscale.xyz;
                gglow.rgb += reflect*(0.5*envscale.xyz);
            ])

            @(? (wtopt "a") [
                #define alpha 1.0
                vec3 rlight = gfetch(refractlight, gl_FragCoord.xy).rgb;
                gglow.rgb += rlight * refractparams.xyz;
            ] [
                #define alpha colorparams.a
            ])

            @(msaapackfrag "" hashid)

            @(? (wtopt "b") [
                float blend = abs(texture2D(blendmap, texcoord1).r - blendlayer);
                gcolor.rgb *= blend;
                gnormal.rgb *= blend;
                gnormal.a *= blendlayer;
                gglow.rgb *= blend;
                gglow.a = blendlayer;
            ] [
                gglow.a = alpha;
            ])
        }
    ]
]

worldshader = [
    worldtype = $arg2
    stype = (? (wtopt "e") 3 1)
    if (wtopt "T") [
        stype = (+ $stype 0x20)
    ]
    defershader $stype $arg1 [
        worldvariantshader @arg1 @arg2
        worldvariantshader @arg1 @(concatword $arg2 "b")
        worldvariantshader @arg1 @(concatword $arg2 "a")
    ]
]

worldvariantshader "stdworld" ""
worldvariantshader "stdworld" "b"
worldvariantshader "stdworld" "a"

worldshader "glowworld" "g"
worldshader "pulseglowworld" "gG"

worldshader "envworldalt" "e"
worldshader "envworld" "er"
altshader envworld envworldalt 
fastshader envworld envworldalt 1

worldshader "envglowworldalt" "eg"
worldshader "envglowworld" "erg"
altshader envglowworld envglowworldalt
fastshader envglowworld envglowworldalt 1

worldshader "envpulseglowworldalt" "egG"
worldshader "envpulseglowworld "ergG"
altshader envpulseglowworld envpulseglowworldalt
fastshader envpulseglowworld envpulseglowworldalt 1

worldshader "triplanarworld" "T"
worldshader "triplanardecalworld" "Td"

// bumptype:
//    e -> reserve envmap texture slot
//    r -> envmap reflection
//    R -> modulate envmap reflection with spec map
//    s -> spec
//    S -> spec map
//    p -> parallax
//    g -> glow
//    G -> pulse glow
//    b -> blendmap
//    a -> refractive
//    T -> triplanar
//    d -> decal

btopt = [ >= (strstr $bumptype $arg1) 0 ]

bumpvariantshader = [
    bumptype = $arg2
    stype = (? (btopt "e") 3 1)
    srow = -1
    if (btopt "G") [
        stype = (+ $stype 0x10)
        defuniformparam "glowcolor" 1 1 1 // glow color
        defuniformparam "pulseglowspeed" 1     // pulse frequency (Hz)
        defuniformparam "pulseglowcolor" 0 0 0 // pulse glow color
    ] [if (btopt "g") [
        defuniformparam "glowcolor" 1 1 1  // glow color
    ]]
    if (btopt "S") [
        defuniformparam "specscale" 6 6 6 // spec map multiplier
    ] [if (btopt "s") [
        defuniformparam "specscale" 1 1 1 // spec multiplier
    ]]
    if (btopt "p") [
        defuniformparam "parallaxscale" 0.06 -0.03 // parallax scaling
    ]
    if (btopt "R") [
        defuniformparam "envscale" 1 1 1 // reflectivity map multiplier
    ] [if (btopt "r") [
        defuniformparam "envscale" 0.2 0.2 0.2 // reflectivity 
    ]]
    if (btopt "T") [
        defuniformparam "triplanarbias" 0.3 0.3 0.3
        stype = (+ $stype 0x20)
    ]
    if (btopt "b") [
        srow = 0
    ]
    if (btopt "a") [
        stype = (+ $stype 4)
        srow = 1
    ]
    variantshader $stype $arg1 $srow [
        attribute vec4 vvertex, vtangent;
        attribute vec3 vnormal;
        attribute vec2 vtexcoord0;
        uniform mat4 camprojmatrix;
        uniform vec2 texgenscroll;
        @(ginterpvert (|| $msaasamples [btopt "a"]))
        @(if (btopt "T") [result [
            uniform vec2 texgenscale;
            varying vec2 texcoordx, texcoordy, texcoordz;
            varying vec3 normal;
            varying vec3 tangentx, tangenty, tangentz;
            @(? (btopt "d") [uniform vec2 decalscale;])
        ]] [result [
            varying vec2 texcoord0;
            varying mat3 world;
        ]])
        @(? (|| (btopt "p") (btopt "r") (btopt "T")) [
            uniform vec3 camera;
            varying vec3 camvec;
        ])
        @(? (btopt "G") [uniform float millis; varying float pulse;])
        @(? (btopt "b") [
            uniform vec4 blendmapparams;
            varying vec2 texcoord1;
        ])

        void main(void)
        {
            gl_Position = camprojmatrix * vvertex;

            @(gdepthpackvert (|| $msaasamples [btopt "a"]))

            @(if (btopt "T") [result [
                texcoordx = vec2(vvertex.y, -vvertex.z) * texgenscale;
                texcoordy = vec2(vvertex.x, -vvertex.z) * texgenscale;
                texcoordz = vvertex.xy * @(? (btopt "d") "decalscale" "texgenscale");
                
                normal = vnormal;
                tangentx = normalize(vec3(1.001, 0.0, 0.0) - vnormal*vnormal.x);
                tangenty = normalize(vec3(0.0, 1.001, 0.0) - vnormal*vnormal.y);
                tangentz = normalize(vec3(0.0, 0.0, -1.001) + vnormal*vnormal.z);
            ]] [result [
                texcoord0 = vtexcoord0 + texgenscroll;                

                vec3 bitangent = cross(vnormal, vtangent.xyz) * vtangent.w;
                // calculate tangent -> world transform
                world = mat3(vtangent.xyz, bitangent, vnormal);
            ]])

            @(? (|| (btopt "p") (btopt "r") (btopt "T")) [
                camvec = camera - vvertex.xyz;
            ])

            @(? (btopt "b") [
                texcoord1 = (vvertex.xy - blendmapparams.xy)*blendmapparams.zw;
            ])

            @(? (btopt "G") [
                pulse = abs(fract(millis*pulseglowspeed.x)*2.0 - 1.0);
            ])
        }
    ] [
        @(if (btopt "a") [result [
            @(gfetchdefs [refractlight refractmask])
            uniform vec4 refractparams;
            uniform float refractdepth;
        ]])
        uniform vec4 colorparams;
        uniform sampler2D diffusemap, normalmap;
        @(? $msaasamples [uniform float hashid;])
        varying mat3 world;
        @(ginterpfrag (|| $msaasamples [btopt "a"]))
        @(if (btopt "T") [result [
            varying vec2 texcoordx, texcoordy, texcoordz;
            varying vec3 normal, tangentx, tangenty, tangentz;
            @(? (btopt "d") [uniform sampler2D decaldiffusemap, decalnormalmap;])
        ]] [result [
            varying vec2 texcoord0;
        ]])
        @(? (|| (btopt "p") (btopt "r") (btopt "T")) [varying vec3 camvec;])
        @(? (btopt "g") [uniform sampler2D glowmap;])
        @(? (btopt "G") [varying float pulse;])
        @(? (btopt "r") [uniform samplerCube envmap;])
        @(? (btopt "b") [
            uniform float blendlayer;
            uniform sampler2D blendmap;
            varying vec2 texcoord1;
        ])

        void main(void)
        {
            @(? (|| (btopt "p") (btopt "r") (btopt "T")) [
                vec3 camvecn = normalize(camvec);
            ])

            @(if (btopt "T") [result [
                vec3 triblend = max(abs(normal) - triplanarbias.xyz, 0.001);
                triblend *= triblend;
                triblend /= triblend.x + triblend.y + triblend.z;

                #define worldx mat3(tangenty, tangentz, normal)
                #define worldy mat3(tangentx, tangentz, normal)
                #define worldz mat3(tangentx, tangenty, normal)

                @(if (btopt "p") [result [
                    float heightx = texture2D(normalmap, texcoordx).a;
                    float heighty = texture2D(normalmap, texcoordy).a;
                    float heightz = texture2D(@(? (btopt "d") "decalnormalmap" "normalmap"), texcoordz).a;
                    vec3 camvect = camvecn * mat3(tangentx, tangenty, tangentz);

                    vec2 dtcx = texcoordx + camvect.yz*(heightx*parallaxscale.x + parallaxscale.y);
                    vec2 dtcy = texcoordy + camvect.xz*(heighty*parallaxscale.x + parallaxscale.y);
                    vec2 dtcz = texcoordz + camvect.xy*(heightz*parallaxscale.x + parallaxscale.y);
                ]] [result [
                    #define dtcx texcoordx
                    #define dtcy texcoordy
                    #define dtcz texcoordz
                ]])

                vec4 diffusex = texture2D(diffusemap, dtcx);
                vec4 diffusey = texture2D(diffusemap, dtcy);
                vec4 diffusez = texture2D(@(? (btopt "d") "decaldiffusemap" "diffusemap"), dtcz);
                vec4 diffuse = diffusex*triblend.x + diffusey*triblend.y + diffusez*triblend.z;

                vec3 bumpx = (texture2D(normalmap, dtcx).rgb*2.0 - 1.0)*triblend.x;
                vec3 bumpy = (texture2D(normalmap, dtcy).rgb*2.0 - 1.0)*triblend.y;
                vec3 bumpz = (texture2D(@(? (btopt "d") "decalnormalmap" "normalmap"), dtcz).rgb*2.0 - 1.0)*triblend.z;
                vec3 bumpw = normalize(worldx*bumpx + worldy*bumpy + worldz*bumpz);

                @(? (btopt "a") [
                    vec2 bump = bumpx.xy + bumpy.xy + bumpz.xy;
                ])
            ]] [result [
                @(? (btopt "p") [
                    float height = texture2D(normalmap, texcoord0).a;
                    vec2 dtc = texcoord0 + (camvecn * world).xy*(height*parallaxscale.x + parallaxscale.y);
                ] [
                    #define dtc texcoord0
                ])

                vec4 diffuse = texture2D(diffusemap, dtc);

                vec3 bump = texture2D(normalmap, dtc).rgb*2.0 - 1.0;
                vec3 bumpw = world * bump;
            ]])

            gcolor.rgb = diffuse.rgb*colorparams.rgb;
            @(if (btopt "s") [
                if (btopt "S") [result [
                    gcolor.a = diffuse.a*specscale.x * 0.5;
                ]] [result [
                    gcolor.a = specscale.x * 0.5;
                ]]
            ] [result [
                gcolor.a = 0.0;
            ]])

            gnormal.rgb = bumpw*0.5 + 0.5;

            @(if (btopt "g") [result [
                @(? (btopt "T") [
                    vec3 glowx = texture2D(glowmap, dtcx).rgb;   
                    vec3 glowy = texture2D(glowmap, dtcy).rgb;   
                    vec3 glowz = texture2D(glowmap, dtcz).rgb;   
                    vec3 glow = glowx*triblend.x + glowy*triblend.y + glowz*triblend.z;
                ] [
                    vec3 glow = texture2D(glowmap, dtc).rgb;
                ])
                @(if (btopt "G") [result [
                    vec3 pulsecol = mix(glowcolor.xyz, pulseglowcolor.xyz, pulse);
                ]])
                glow *= @(? (btopt "G") "pulsecol" "glowcolor.xyz"); 
                gglow.rgb = glow;
            ]] [result [
                gglow.rgb = vec3(0.0);
            ]])
 
            @(if (btopt "r") [result [
                float invfresnel = dot(camvecn, bumpw);
                vec3 rvec = 2.0*bumpw*invfresnel - camvecn;
                vec3 reflect = textureCube(envmap, rvec).rgb;
                @(if (btopt "R") [result [
                    vec3 rmod = envscale.xyz*diffuse.a;
                ]] [result [
                    #define rmod envscale.xyz
                ]])
                gcolor.rgb = mix(gcolor.rgb, reflect, rmod*clamp(1.0 - invfresnel, 0.0, 1.0));
            ]])

            @(? (btopt "a") [
                #define alpha 1.0
                vec2 rtc = bump.xy*refractparams.w;
                float rmask = clamp(refractdepth*(lineardepth - dot(gfetch(refractmask, gl_FragCoord.xy + rtc).rgb, gdepthunpackparams)), 0.0, 1.0);
                vec3 rlight = gfetch(refractlight, gl_FragCoord.xy + rtc*rmask).rgb;
                gglow.rgb += rlight * refractparams.xyz;
            ] [
                #define alpha colorparams.a
            ])

            @(gdepthpackfrag $msaasamples "" hashid)

            @(? (btopt "b") [
                float blend = abs(texture2D(blendmap, texcoord1).r - blendlayer);
                gcolor *= blend;
                gnormal.rgb *= blend;
                gnormal.a *= blendlayer;
                gglow.rgb *= blend;
                gglow.a = blendlayer;
            ] [
                gglow.a = alpha;
            ])
        }
    ]
]

bumpshader = [
    bumptype = $arg2
    stype = (? (btopt "e") 3 1)
    if (btopt "T") [
        stype = (+ $stype 0x20)
    ]
    defershader $stype $arg1 [
        bumpvariantshader @arg1 @arg2
        bumpvariantshader @arg1 @(concatword $arg2 "b")
        bumpvariantshader @arg1 @(concatword $arg2 "a")
    ]
]

bumpshader "bumpworld" ""
bumpshader "bumpspecworld" "s"
fastshader bumpspecworld bumpworld 2
altshader bumpspecworld bumpworld
bumpshader "bumpspecmapworld" "sS"
fastshader bumpspecmapworld bumpworld 2
altshader bumpspecmapworld bumpworld

bumpshader "bumpglowworld" "g"
bumpshader "bumpspecglowworld" "sg"
altshader bumpspecglowworld bumpglowworld
bumpshader "bumpspecmapglowworld" "sSg"
fastshader bumpspecmapglowworld bumpglowworld 2
altshader bumpspecmapglowworld bumpglowworld

bumpshader "bumppulseglowworld" "gG"
bumpshader "bumpspecpulseglowworld" "sgG"
altshader bumpspecpulseglowworld bumppulseglowworld
bumpshader "bumpspecmappulseglowworld" "sSgG"
fastshader bumpspecmappulseglowworld bumppulseglowworld 2
altshader bumpspecmappulseglowworld bumppulseglowworld

bumpshader "bumpparallaxworld" "p"
fastshader bumpparallaxworld bumpworld 1
altshader bumpparallaxworld bumpworld
bumpshader "bumpspecparallaxworld" "ps"
fastshader bumpspecparallaxworld bumpparallaxworld 2
fastshader bumpspecparallaxworld bumpworld 1
altshader bumpspecparallaxworld bumpworld
bumpshader "bumpspecmapparallaxworld" "psS"
fastshader bumpspecmapparallaxworld bumpparallaxworld 2
fastshader bumpspecmapparallaxworld bumpworld 1
altshader bumpspecmapparallaxworld bumpworld

bumpshader "bumpparallaxglowworld" "pg"
fastshader bumpparallaxglowworld bumpglowworld 1
altshader bumpparallaxglowworld bumpglowworld
bumpshader "bumpspecparallaxglowworld" "psg"
fastshader bumpspecparallaxglowworld bumpparallaxglowworld 2
fastshader bumpspecparallaxglowworld bumpglowworld 1
altshader bumpspecparallaxglowworld bumpglowworld
bumpshader "bumpspecmapparallaxglowworld" "psSg"
fastshader bumpspecmapparallaxglowworld bumpparallaxglowworld 2
fastshader bumpspecmapparallaxglowworld bumpglowworld 1
altshader bumpspecmapparallaxglowworld bumpglowworld

bumpshader "bumpparallaxpulseglowworld" "pgG"
fastshader bumpparallaxpulseglowworld bumppulseglowworld 1
altshader bumpparallaxpulseglowworld bumppulseglowworld
bumpshader "bumpspecparallaxpulseglowworld" "psgG"
fastshader bumpspecparallaxpulseglowworld bumpparallaxpulseglowworld 2
fastshader bumpspecparallaxpulseglowworld bumppulseglowworld 1
altshader bumpspecparallaxpulseglowworld bumppulseglowworld
bumpshader "bumpspecmapparallaxpulseglowworld" "psSgG"
fastshader bumpspecmapparallaxpulseglowworld bumpparallaxpulseglowworld 2
fastshader bumpspecmapparallaxpulseglowworld bumppulseglowworld 1
altshader bumpspecmapparallaxpulseglowworld bumppulseglowworld

bumpshader "bumpenvworldalt" "e"
bumpshader "bumpenvworld" "er"
altshader bumpenvworld bumpenvworldalt
fastshader bumpenvworld bumpenvworldalt 2
bumpshader "bumpenvspecworld" "esr"
altshader bumpenvspecworld bumpenvworldalt
fastshader bumpenvspecworld bumpenvworldalt 2
bumpshader "bumpenvspecmapworld" "esSrR"
altshader bumpenvspecmapworld bumpenvworldalt
fastshader bumpenvspecmapworld bumpenvworldalt 2

bumpshader "bumpenvglowworldalt" "eg"
bumpshader "bumpenvglowworld" "erg"
altshader bumpenvglowworld bumpenvglowworldalt
fastshader bumpenvglowworld bumpenvglowworldalt 2
bumpshader "bumpenvspecglowworld" "eosrg"
altshader bumpenvspecglowworld bumpenvglowworldalt
fastshader bumpenvspecglowworld bumpenvglowworldalt 2
bumpshader "bumpenvspecmapglowworld" "esSrRg"
altshader bumpenvspecmapglowworld bumpenvglowworldalt
fastshader bumpenvspecmapglowworld bumpenvglowworldalt 2

bumpshader "bumpenvpulseglowworldalt" "egG"
bumpshader "bumpenvpulseglowworld" "eorgG"
altshader bumpenvpulseglowworld bumpenvpulseglowworldalt
fastshader bumpenvpulseglowworld bumpenvpulseglowworldalt 2
bumpshader "bumpenvspecpulseglowworld" "esrgG"
altshader bumpenvspecpulseglowworld bumpenvpulseglowworldalt
fastshader bumpenvspecpulseglowworld bumpenvpulseglowworldalt 2
bumpshader "bumpenvspecmappulseglowworld" "esSrRgG"
altshader bumpenvspecmappulseglowworld bumpenvpulseglowworldalt
fastshader bumpenvspecmappulseglowworld bumpenvpulseglowworldalt 2

bumpshader "bumpenvparallaxworldalt" "ep"
altshader bumpenvparallaxworldalt bumpenvworldalt
bumpshader "bumpenvparallaxworld" "epr"
altshader bumpenvparallaxworld bumpenvparallaxworldalt
fastshader bumpenvparallaxworld bumpenvparallaxworldalt 2
fastshader bumpenvparallaxworld bumpenvworldalt 1
bumpshader "bumpenvspecparallaxworld" "epsr"
altshader bumpenvspecparallaxworld bumpenvparallaxworldalt
fastshader bumpenvspecparallaxworld bumpenvparallaxworldalt 2
fastshader bumpenvspecparallaxworld bumpenvworldalt 1
bumpshader "bumpenvspecmapparallaxworld" "epsSrR"
altshader bumpenvspecmapparallaxworld bumpenvparallaxworldalt
fastshader bumpenvspecmapparallaxworld bumpenvparallaxworldalt 2
fastshader bumpenvspecmapparallaxworld bumpenvworldalt 1

bumpshader "bumpenvparallaxglowworldalt" "epg"
altshader bumpenvparallaxglowworldalt bumpenvglowworldalt
bumpshader "bumpenvparallaxglowworld" "eprg"
altshader bumpenvparallaxglowworld bumpenvparallaxglowworldalt
fastshader bumpenvparallaxglowworld bumpenvparallaxglowworldalt 2
fastshader bumpenvparallaxglowworld bumpenvglowworldalt 1
bumpshader "bumpenvspecparallaxglowworld" "epsrg"
altshader bumpenvspecparallaxglowworld bumpenvparallaxglowworldalt
fastshader bumpenvspecparallaxglowworld bumpenvparallaxglowworldalt 2
fastshader bumpenvspecparallaxglowworld bumpenvglowworldalt 1
bumpshader "bumpenvspecmapparallaxglowworld" "epsSrRg"
altshader bumpenvspecmapparallaxglowworld bumpenvparallaxglowworldalt
fastshader bumpenvspecmapparallaxglowworld bumpenvparallaxglowworldalt 2
fastshader bumpenvspecmapparallaxglowworld bumpenvglowworldalt 1

bumpshader "bumpenvparallaxpulseglowworldalt" "epgG"
altshader bumpenvparallaxpulseglowworldalt bumpenvpulseglowworldalt
bumpshader "bumpenvparallaxpulseglowworld" "eprgG"
altshader bumpenvparallaxpulseglowworld bumpenvparallaxpulseglowpulseglowworldalt
fastshader bumpenvparallaxpulseglowworld bumpenvparallaxpulseglowpulseglowworldalt 2
fastshader bumpenvparallaxpulseglowworld bumpenvpulseglowworldalt 1
bumpshader "bumpenvspecparallaxpulseglowworld" "epsrgG"
altshader bumpenvspecparallaxpulseglowworld bumpenvparallaxpulseglowworldalt
fastshader bumpenvspecparallaxpulseglowworld bumpenvparallaxpulseglowworldalt 2
fastshader bumpenvspecparallaxpulseglowworld bumpenvpulseglowworldalt 1
bumpshader "bumpenvspecmapparallaxpulseglowworld" "epsSrRgG"
altshader bumpenvspecmapparallaxpulseglowworld bumpenvparallaxpulseglowworldalt
fastshader bumpenvspecmapparallaxpulseglowworld bumpenvparallaxpulseglowworldalt 2
fastshader bumpenvspecmapparallaxpulseglowworld bumpenvpulseglowworldalt 1

bumpshader "triplanarbumpworld" "T"
bumpshader "triplanarbumpspecworld" "Ts"
fastshader triplanarbumpspecworld triplanarbumpworld 2
altshader triplanarbumpspecworld triplanarbumpworld
bumpshader "triplanarbumpspecmapworld" "TsS"
fastshader triplanarbumpspecmapworld triplanarbumpworld 2
altshader triplanarbumpspecmapworld triplanarbumpworld
bumpshader "triplanarbumpparallaxworld" "Tp"
fastshader triplanarbumpparallaxworld triplanarbumpworld 1
altshader triplanarbumpparallaxworld triplanarbumpworld

bumpshader "triplanarbumpspecparallaxworld" "Tps"
fastshader triplanarbumpspecparallaxworld triplanarbumpparallaxworld 2
fastshader triplanarbumpspecparallaxworld triplanarbumpworld 1
altshader triplanarbumpspecparallaxworld triplanarbumpworld
bumpshader "triplanarbumpspecmapparallaxworld" "TpsS"
fastshader triplanarbumpspecmapparallaxworld triplanarbumpparallaxworld 2
fastshader triplanarbumpspecmapparallaxworld triplanarbumpworld 1
altshader triplanarbumpspecmapparallaxworld triplanarbumpworld

bumpshader "triplanardecalbumpworld" "Td"
bumpshader "triplanardecalbumpspecworld" "Tds"
fastshader triplanardecalbumpspecworld triplanardecalbumpworld 2
altshader triplanardecalbumpspecworld triplanardecalbumpworld
bumpshader "triplanardecalbumpspecmapworld" "TdsS"
fastshader triplanardecalbumpspecmapworld triplanardecalbumpworld 2
altshader triplanardecalbumpspecmapworld triplanardecalbumpworld
bumpshader "triplanardecalbumpparallaxworld" "Tdp"
fastshader triplanardecalbumpparallaxworld triplanardecalbumpworld 1
altshader triplanardecalbumpparallaxworld triplanardecalbumpworld

bumpshader "triplanardecalbumpspecparallaxworld" "Tdps"
fastshader triplanardecalbumpspecparallaxworld triplanardecalbumpparallaxworld 2
fastshader triplanardecalbumpspecparallaxworld triplanardecalbumpworld 1
altshader triplanardecalbumpspecparallaxworld triplanardecalbumpworld
bumpshader "triplanardecalbumpspecmapparallaxworld" "TdpsS"
fastshader triplanardecalbumpspecmapparallaxworld triplanardecalbumpparallaxworld 2
fastshader triplanardecalbumpspecmapparallaxworld triplanardecalbumpworld 1
altshader triplanardecalbumpspecmapparallaxworld triplanardecalbumpworld

shader 0 shadowmapworld [
    attribute vec4 vvertex;
    uniform mat4 shadowmatrix;
    void main(void)
    {
        gl_Position = shadowmatrix * vvertex;
    }
] [
    void main(void)
    {
    }
]

defershader 1 "rsmworld" [
  loop i 2 [
    variantshader 1 "rsmworld" (- $i 1) [
        attribute vec4 vvertex;
        attribute vec3 vnormal;
        attribute vec2 vtexcoord0;
        uniform mat4 rsmmatrix;
        uniform vec2 texgenscroll;
        uniform vec4 colorparams;
        uniform vec3 rsmdir;
        varying vec4 normal;
        varying vec2 texcoord0;
        @(? (= $i 1) [
            uniform vec4 blendmapparams;
            varying vec2 texcoord1;
        ])
        void main(void)
        {
            gl_Position = rsmmatrix * vvertex;
            texcoord0 = vtexcoord0 + texgenscroll;
            @(if (= $i 1) [result [
                texcoord1 = (vvertex.xy - blendmapparams.xy)*blendmapparams.zw;
            ]])
            normal = vec4(vnormal, dot(vnormal, rsmdir));
        }
    ] [
        uniform vec4 colorparams;
        uniform sampler2D diffusemap;
        varying vec4 normal;
        varying vec2 texcoord0;
        @(? (= $i 1) [
            uniform float blendlayer;
            uniform sampler2D blendmap;
            varying vec2 texcoord1;
        ])
        fragdata(0, gcolor, vec4)
        fragdata(1, gnormal, vec4)
        void main(void)
        {
            vec4 diffuse = texture2D(diffusemap, texcoord0);   

            @(if (= $i 2) [result [
                #define alpha 1.0
            ]] [result [
                #define alpha colorparams.a
            ]])

            gcolor.rgb = normal.w*diffuse.rgb*colorparams.rgb;
            gnormal = vec4(normal.xyz*0.5+0.5, 0.0);

            @(if (= $i 1) [result [
                float blend = abs(texture2D(blendmap, texcoord1).r - blendlayer);
                gcolor.rgb *= blend;
                gcolor.a = blendlayer;
                gnormal *= blend;
            ]] [result [
                gcolor.a = alpha;
            ]])
        }
    ]
  ]
]

lazyshader 0 "rsmsky" [
    attribute vec4 vvertex;
    uniform mat4 rsmmatrix;
    void main(void)
    {
        gl_Position = rsmmatrix * vvertex;
    }
] [
    fragdata(0, gcolor, vec4)
    fragdata(1, gnormal, vec4)
    void main(void)
    {
        gcolor = vec4(0.0, 0.0, 0.0, 1.0);
        gnormal = vec4(0.5, 0.5, 0.5, 0.0);
    }
]

////////////////////////////////////////////////
//
// model shaders
//
////////////////////////////////////////////////

// skeletal animation with dual quaternions

qtangentdecode = [
    ? $arg1 [
        vec4 qxyz = mquat.xxyy*mquat.yzyz, qxzw = vec4(mquat.xzw, -mquat.w);
        vec3 mtangent = (qxzw.yzw*mquat.zzy + qxyz.zxy)*vec3(-2.0, 2.0, 2.0) + vec3(1.0, 0.0, 0.0);
        vec3 mnormal = (qxzw.zwx*mquat.yxx + qxyz.ywz)*vec3(2.0, 2.0, -2.0) + vec3(0.0, 0.0, 1.0);
        // vec3 mtangent = cross(mquat.xyz, vec3(mquat.wz, -mquat.y))*2.0 + vec3(1.0, 0.0, 0.0);
        // vec3 mnormal = cross(mquat.xyz, vec3(mquat.y, -mquat.x, mquat.w))*2.0 + vec3(0.0, 0.0, 1.0);
    ] [
        vec3 mnormal = cross(mquat.xyz, vec3(mquat.y, -mquat.x, mquat.w))*2.0 + vec3(0.0, 0.0, 1.0);
    ]
]
    
skelanimdefs = [
    result [
        attribute vec4 vboneweight, vboneindex; 
        #pragma CUBE2_uniform animdata
        uniform vec4 animdata[@@(min $maxvsuniforms $maxskelanimdata)];
    ]
]

skelanim = [
    result [
        int index = int(vboneindex.x);
        @(if (= $arg1 1) [result [
            vec4 dqreal = animdata[index];
            vec4 dqdual = animdata[index+1];
        ]] [result [ 
            vec4 dqreal = animdata[index] * vboneweight.x;
            vec4 dqdual = animdata[index+1] * vboneweight.x;
            index = int(vboneindex.y);
            dqreal += animdata[index] * vboneweight.y;
            dqdual += animdata[index+1] * vboneweight.y;
            @(if (>= $arg1 3) [result [
                index = int(vboneindex.z);
                dqreal += animdata[index] * vboneweight.z;
                dqdual += animdata[index+1] * vboneweight.z;
            ]])
            @(if (>= $arg1 4) [result [
                index = int(vboneindex.w);
                dqreal += animdata[index] * vboneweight.w;
                dqdual += animdata[index+1] * vboneweight.w;
            ]])
            float len = length(dqreal);
            dqreal /= len;
            dqdual /= len;
        ]])

        vec4 mpos = vec4((cross(dqreal.xyz, cross(dqreal.xyz, vvertex.xyz) + vvertex.xyz*dqreal.w + dqdual.xyz) + dqdual.xyz*dqreal.w - dqreal.xyz*dqdual.w)*2.0 + vvertex.xyz, vvertex.w);

        @(if (>= $numargs 2) [result [
            vec4 mquat = vec4(cross(dqreal.xyz, vtangent.xyz) + dqreal.xyz*vtangent.w + vtangent.xyz*dqreal.w, dqreal.w*vtangent.w - dot(dqreal.xyz, vtangent.xyz));
            @(qtangentdecode $arg2)
        ]])
    ]
]

// mdltype:
//    a -> alpha test
//    b -> dual-quat skeletal animation

mdlopt = [ >= (strstr $modeltype $arg1) 0 ]

shadowmodelvertexshader = [
    modeltype = $arg1
    result [
        attribute vec4 vvertex;
        @(if (mdlopt "b") [skelanimdefs $arg2])
        uniform mat4 modelmatrix;
        @(? (mdlopt "a") [
            attribute vec2 vtexcoord0;
            uniform vec2 texscroll;
            varying vec2 texcoord0;
        ])
        void main(void)
        {
            @(if (mdlopt "b") [
                skelanim $arg2
            ] [result [
                #define mpos vvertex
            ]])
            
            gl_Position = modelmatrix * mpos;

            @(? (mdlopt "a") [
                texcoord0 = vtexcoord0 + texscroll;
            ])
        }
    ]
]

shadowmodelfragmentshader = [
    modeltype = $arg1
    result [
        @(? (mdlopt "a") [
            uniform sampler2D tex0;
            uniform float alphatest;
            varying vec2 texcoord0;
        ])
        void main(void)
        {
            @(? (mdlopt "a") [
                vec4 color = texture2D(tex0, texcoord0);
                if(color.a <= alphatest)    
                    discard;
            ])
        }
    ]
]

shadowmodelshader = [
    defershader 0 $arg1 [
        shader 0 @arg1 (shadowmodelvertexshader @arg2) (shadowmodelfragmentshader @arg2)
        loop+ i 1 4 [
            variantshader 0 @@arg1 0 (shadowmodelvertexshader @@(concatword $arg2 "b") $i) []
        ]
    ]
]

shadowmodelshader "shadowmodel" ""
shadowmodelshader "alphashadowmodel" "a"

// mdltype:
//    a -> alpha test
//    e -> envmap
//    n -> normalmap
//    m -> masks
//    d -> decal
//    D -> alpha decal
//    b -> dual-quat skeletal animation

modelvertexshader = [
    modeltype = $arg1
    result [
        attribute vec4 vvertex, vtangent;
        attribute vec2 vtexcoord0;
        @(if (mdlopt "b") [skelanimdefs $arg2 (mdlopt "n")])
        uniform mat4 modelmatrix;
        uniform mat3 modelworld;
        uniform vec3 modelcamera;
        uniform vec2 texscroll;
        @(if (mdlopt "n") [result [
            varying mat3 world;
            @(if (mdlopt "e") [result [
                varying vec3 camvec;
            ]])
        ]] [result [
            varying vec3 nvec;
            @(if (mdlopt "e") [result [
                uniform vec2 envmapscale;
                varying vec3 rvec;
                varying float rmod;
            ]])
        ]])
        @(msaainterpvert)
        varying vec2 texcoord0;

        void main(void)
        {
            @(if (mdlopt "b") [
                skelanim $arg2 (mdlopt "n")
            ] [result [
                #define mpos vvertex
                #define mquat vtangent
                @(qtangentdecode (mdlopt "n"))
            ]])

            gl_Position = modelmatrix * mpos;

            texcoord0 = vtexcoord0 + texscroll;
    
            @(msaapackvert)
 
            @(? (mdlopt "e") [
                vec3 camdir = modelworld * normalize(modelcamera - mpos.xyz);
            ])

            @(if (mdlopt "n") [result [
                @(if (mdlopt "e") [result [
                    camvec = camdir;
                ]])
                // composition of tangent -> object and object -> world transforms
                //   becomes tangent -> world
                vec3 wnormal = modelworld * mnormal;
                vec3 wtangent = modelworld * mtangent;
                vec3 wbitangent = cross(wnormal, wtangent) * (vtangent.w < 0.0 ? -1.0 : 1.0);
                world = mat3(wtangent, wbitangent, wnormal);
            ]] [result [
                vec3 wnormal = modelworld * mnormal;
                nvec = wnormal; 
                @(if (mdlopt "e") [result [
                    float invfresnel = dot(camdir, wnormal);
                    rvec = 2.0*invfresnel*wnormal - camdir;
                    rmod = envmapscale.x*max(invfresnel, 0.0) + envmapscale.y;    
                ]])
            ]])
        }
    ] 
]

modelfragmentshader = [
    modeltype = $arg1
    result [
        @(if (mdlopt "n") [result [
            varying mat3 world; 
            @(if (mdlopt "e") [result [
                uniform vec2 envmapscale;
                varying vec3 camvec;
            ]])
        ]] [result [
            varying vec3 nvec;
            @(if (mdlopt "e") [result [
                varying vec3 rvec;
                varying float rmod;
            ]])
        ]])
        uniform vec4 colorscale;
        uniform vec2 fullbright;
        uniform vec2 maskscale;
        @(? (mdlopt "a") [uniform float alphatest;])
        uniform sampler2D tex0;
        @(? (mdlopt "m") [uniform sampler2D tex1;])
        @(? (mdlopt "e") [uniform samplerCube tex2;])
        @(? (mdlopt "n") [uniform sampler2D tex3;])
        @(? (|| (mdlopt "d") [mdlopt "D"]) [uniform sampler2D tex4;])
        @(msaainterpfrag)
        varying vec2 texcoord0;
        uniform float aamask;

        void main(void)
        {
            vec4 diffuse = texture2D(tex0, texcoord0);

            @(? (mdlopt "a") [
                if(diffuse.a <= alphatest)
                    discard;
            ])
            
            gcolor.rgb = diffuse.rgb*colorscale.rgb;

            @(? (|| (mdlopt "d") [mdlopt "D"]) [
                vec4 decal = texture2D(tex4, texcoord0);
                @(? (mdlopt "D") [
                    gcolor.rgb = mix(gcolor.rgb, decal.rgb, decal.a);
                ] [
                    gcolor.rgb += decal.rgb;
                ])
            ])

            float spec = maskscale.x;
            @(? (mdlopt "m") [
                vec3 masks = texture2D(tex1, texcoord0).rgb;
                spec *= masks.r; // specmap in red channel
            ])
            gcolor.a = 0.5*spec;

            @(? (mdlopt "n") [
                vec3 normal = texture2D(tex3, texcoord0).rgb - 0.5;
                normal = normalize(world * normal);
            ] [
                vec3 normal = normalize(nvec);
            ])

            gnormal.rgb = 0.5*normal+0.5;

            @(if (mdlopt "m") [result [
                float gmask = max(maskscale.y*masks.g, fullbright.y); // glow mask in green channel
                gglow.rgb = gcolor.rgb*gmask;
                gcolor.rgb *= fullbright.x-gmask;
                @(if (mdlopt "e") [result [
                    @(if (mdlopt "n") [result [
                        vec3 camn = normalize(camvec);
                        float invfresnel = dot(camn, normal);
                        vec3 rvec = 2.0*invfresnel*normal - camn;
                        float rmod = envmapscale.x*clamp(invfresnel, 0.0, 1.0) + envmapscale.y;
                    ]])
                    float rmask = rmod*masks.b; // envmap mask in blue channel
                    vec3 reflect = textureCube(tex2, rvec).rgb;
                    gcolor.rgb = mix(gcolor.rgb, reflect, rmask);
                ]])
            ]] [result [
                gglow.rgb = gcolor.rgb*fullbright.y;
                gcolor.rgb *= fullbright.x-fullbright.y;
            ]])

            gglow.a = colorscale.a;
 
            @(msaapackfrag aamask)
        }
    ]
]

modelshader = [
    shadername = (concatword "model" $arg1)
    shader 0 $shadername (modelvertexshader $arg1) (modelfragmentshader $arg1)
    loop+ i 1 4 [
        variantshader 0 $shadername 0 (modelvertexshader (concatword $arg1 "b") $i) []
    ]
]

rsmmodelvertexshader = [
    modeltype = $arg1
    result [
        attribute vec4 vvertex, vtangent;
        attribute vec2 vtexcoord0;
        @(if (mdlopt "b") [skelanimdefs $arg2 (mdlopt "n")])
        uniform mat4 modelmatrix;
        uniform mat3 modelworld;
        uniform vec2 texscroll;
        uniform vec3 rsmdir;
        varying vec2 texcoord0;
        varying vec4 normal;
        void main(void)
        {
            @(if (mdlopt "b") [
                skelanim $arg2 (mdlopt "n")
            ] [result [
                #define mpos vvertex
                #define mquat vtangent
                @(qtangentdecode (mdlopt "n"))
            ]])

            gl_Position = modelmatrix * mpos;

            texcoord0 = vtexcoord0 + texscroll;

            normal.xyz = modelworld * mnormal;
            normal.w = dot(normal.xyz, rsmdir);
        }
    ]
]

rsmmodelfragmentshader = [
    modeltype = $arg1
    result [
        varying vec2 texcoord0;
        varying vec4 normal;
        uniform vec4 colorscale;
        @(? (mdlopt "a") [uniform float alphatest;])
        uniform sampler2D tex0;
        fragdata(0, gcolor, vec4)
        fragdata(1, gnormal, vec4)
        void main(void)
        {
            vec4 diffuse = texture2D(tex0, texcoord0);
            @(? (mdlopt "a") [
                if(diffuse.a <= alphatest)
                    discard;
            ])
            gcolor = vec4(normal.w*diffuse.rgb*colorscale.rgb, 1.0);
            gnormal = vec4(normal.xyz*0.5+0.5, 0.0);
        }
    ]
]

rsmmodelshader = [
    defershader 0 $arg1 [
        shader 0 @arg1 (rsmmodelvertexshader @arg2) (rsmmodelfragmentshader @arg2)
        loop+ i 1 4 [
            variantshader 0 @@arg1 0 (rsmmodelvertexshader @@(concatword $arg2 "b") $i) []
        ]
    ]
]

rsmmodelshader "rsmmodel" ""
rsmmodelshader "rsmalphamodel "a"

rhtapoffsets12 = [
"0.0565813, 0.61211, 0.763359"
"0.375225, 0.285592, 0.987915"
"0.615192, 0.668996, 0.604938"
"0.963195, 0.355937, 0.175787"
"0.0295724, 0.484268, 0.265694"
"0.917783, 0.88702, 0.201972"
"0.408948, 0.0675985, 0.427564"
"0.19071, 0.923612, 0.0553606"
"0.968078, 0.403943, 0.847224"
"0.384503, 0.922269, 0.990844"
"0.480605, 0.342418, 0.00195318"
"0.956664, 0.923643, 0.915799"
]

rhtapoffsets20 = [
"0.0540788, 0.411725, 0.134068"
"0.0163579, 0.416211, 0.992035"
"0.692068, 0.549272, 0.886502"
"0.305795, 0.781854, 0.571337"
"0.791681, 0.139042, 0.247047"
"0.83929, 0.973663, 0.460982"
"0.0336314, 0.0867641, 0.582324"
"0.148198, 0.961974, 0.0378124"
"0.948729, 0.0713828, 0.916379"
"0.586413, 0.591845, 0.031251"
"0.00189215, 0.973968, 0.932981"
"0.435865, 0.0853603, 0.995148"
"0.36848, 0.820612, 0.942717"
"0.500107, 0.0658284, 0.623005"
"0.580187, 0.4485, 0.379223"
"0.258614, 0.0201422, 0.241005"
"0.987152, 0.441664, 0.43318"
"0.925108, 0.917203, 0.921506"
"0.988372, 0.822047, 0.12479"
"0.330393, 0.43611, 0.762566"
]

rhtapoffsets32 = [
"0.0553911, 0.675924, 0.22129"
"0.562975, 0.508286, 0.549883"
"0.574816, 0.703452, 0.0513016"
"0.981017, 0.930479, 0.243873"
"0.889309, 0.133091, 0.319071"
"0.329112, 0.00759911, 0.472213"
"0.314463, 0.985839, 0.54442"
"0.407697, 0.202643, 0.985748"
"0.998169, 0.760369, 0.792932"
"0.0917692, 0.0666829, 0.0169683"
"0.0157781, 0.632954, 0.740806"
"0.938139, 0.235878, 0.87936"
"0.442305, 0.184942, 0.0901212"
"0.578051, 0.863948, 0.799554"
"0.0698569, 0.259194, 0.667592"
"0.872494, 0.576312, 0.344157"
"0.10123, 0.930082, 0.959929"
"0.178594, 0.991302, 0.046205"
"0.690176, 0.527543, 0.930509"
"0.982025, 0.389447, 0.0344554"
"0.033845, 0.0156865, 0.963866"
"0.655293, 0.154271, 0.640553"
"0.317881, 0.598621, 0.97998"
"0.247261, 0.398206, 0.121586"
"0.822626, 0.985076, 0.655232"
"0.00201422, 0.434278, 0.388348"
"0.511399, 0.977416, 0.278695"
"0.32371, 0.540147, 0.361187"
"0.365856, 0.41493, 0.758232"
"0.792871, 0.979217, 0.0309763"
"0.0509049, 0.459151, 0.996277"
"0.0305185, 0.13422, 0.306009"
]

rsmtapoffsets12 = [
"0.031084, 0.572114"
"0.040671, 0.95653"
"0.160921, 0.367819"
"0.230518, 0.134321"
"0.247078, 0.819415"
"0.428665, 0.440522"
"0.49846, 0.80717"
"0.604285, 0.0307766"
"0.684075, 0.283001"
"0.688304, 0.624171"
"0.833995, 0.832414"
"0.975397, 0.189911"
]

rsmtapoffsets20 = [
"0.00240055, 0.643992"
"0.0356464, 0.851616"
"0.101733, 0.21876"
"0.166119, 0.0278085"
"0.166438, 0.474999"
"0.24991, 0.766405"
"0.333714, 0.130407"
"0.400681, 0.374781"
"0.424067, 0.888211"
"0.448511, 0.678962"
"0.529383, 0.213568"
"0.608569, 0.47715"
"0.617996, 0.862528"
"0.631784, 0.0515881"
"0.740969, 0.20753"
"0.788203, 0.41923"
"0.794066, 0.615141"
"0.834504, 0.836612"
"0.89446, 0.0677863"
"0.975609, 0.446056"
]

rsmtapoffsets32 = [
"0.0262032, 0.215221"
"0.0359769, 0.0467256"
"0.0760799, 0.713481"
"0.115087, 0.461431"
"0.119488, 0.927444"
"0.22346, 0.319747"
"0.225964, 0.679227"
"0.238626, 0.0618425"
"0.243326, 0.535066"
"0.29832, 0.90826"
"0.335208, 0.212103"
"0.356438, 0.751969"
"0.401021, 0.478664"
"0.412027, 0.0245297"
"0.48477, 0.320659"
"0.494311, 0.834621"
"0.515007, 0.165552"
"0.534574, 0.675536"
"0.585357, 0.432483"
"0.600102, 0.94139"
"0.650182, 0.563571"
"0.672336, 0.771816"
"0.701811, 0.187078"
"0.734207, 0.359024"
"0.744775, 0.924466"
"0.763628, 0.659075"
"0.80735, 0.521281"
"0.880585, 0.107684"
"0.898505, 0.904047"
"0.902536, 0.718989"
"0.928022, 0.347802"
"0.971243, 0.504885"
]

radiancehintsshader = [
  numtaps = (cond [> $arg1 20] 32 [> $arg1 12] 20 12)
  shader 0 [radiancehints@arg1] [
    attribute vec4 vvertex;
    attribute vec3 vtexcoord0;
    uniform mat4 rsmtcmatrix;
    varying vec3 rhcenter;
    varying vec2 rsmcenter;
    void main(void)
    {
        gl_Position = vvertex;
        rhcenter = vtexcoord0;
        rsmcenter = (rsmtcmatrix * vec4(vtexcoord0, 1.0)).xy;
    }
  ] [
    uniform sampler2DRect tex0, tex1, tex2; 
    uniform mat4 rsmworldmatrix;
    uniform vec2 rsmspread;
    uniform float rhatten, rhspread, rhaothreshold, rhaoatten, rhaoheight;
    uniform vec3 rsmdir;
    varying vec3 rhcenter;
    varying vec2 rsmcenter;
    fragdata(0, rhr, vec4)
    fragdata(1, rhg, vec4)
    fragdata(2, rhb, vec4)
    fragdata(3, rha, vec4)

    void calcrhsample(vec3 rhtap, vec2 rsmtap, inout vec4 shr, inout vec4 shg, inout vec4 shb, inout vec4 sha)
    {
        vec3 rhpos = rhcenter + rhtap*rhspread;
        vec2 rsmtc = rsmcenter + rsmtap*rsmspread;
        float rsmdepth = texture2DRect(tex0, rsmtc).x;
        vec3 rsmcolor = texture2DRect(tex1, rsmtc).rgb;
        vec3 rsmnormal = texture2DRect(tex2, rsmtc).xyz*2.0 - 1.0;
        vec3 rsmpos = (rsmworldmatrix * vec4(rsmtc, rsmdepth, 1.0)).xyz;

        vec3 dir = rhpos - rsmpos;

        sha += step(rhaothreshold, dir.z) * vec4(normalize(vec3(dir.xy, min(dot(dir.xy, dir.xy) * rhaoatten - rhaoheight, 0.0))), 1.0);

        float dist = dot(dir, dir);
        if(dist > 0.000049) dir = normalize(dir);
        float atten = clamp(dot(dir, rsmnormal), 0.0, 1.0) / (0.1 + dist*rhatten);
        rsmcolor *= atten;

        shr += vec4(rsmcolor.r*dir, rsmcolor.r);
        shg += vec4(rsmcolor.g*dir, rsmcolor.g);
        shb += vec4(rsmcolor.b*dir, rsmcolor.b);
    }

    void main(void)
    {
        vec4 shr = vec4(0.0), shg = vec4(0.0), shb = vec4(0.0), sha = vec4(0.0);

        @(loopconcat i $numtaps [result [
            calcrhsample(vec3(@(at $[rhtapoffsets@numtaps] $i))*2.0 - 1.0, vec2(@(at $[rsmtapoffsets@numtaps] $i))*2.0 - 1.0, shr, shg, shb, sha);
        ]])

        rhr = shr * (vec4(0.5, 0.5, 0.5, 1.0)/@(+f $numtaps)) + vec4(0.5, 0.5, 0.5, 0.0);
        rhg = shg * (vec4(0.5, 0.5, 0.5, 1.0)/@(+f $numtaps)) + vec4(0.5, 0.5, 0.5, 0.0);
        rhb = shb * (vec4(0.5, 0.5, 0.5, 1.0)/@(+f $numtaps)) + vec4(0.5, 0.5, 0.5, 0.0);
        rha = sha * (vec4(0.5, 0.5, 0.5, 1.0)/@(+f $numtaps)) + vec4(0.5, 0.5, 0.5, 0.0);
    }
  ]
]

lazyshader 0 radiancehintsborder [
    attribute vec4 vvertex;
    attribute vec3 vtexcoord0;
    varying vec3 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0;
    }
] [
    uniform sampler3D tex3, tex4, tex5, tex6;
    uniform vec3 bordercenter, borderrange, borderscale;
    varying vec3 texcoord0;
    fragdata(0, rhr, vec4)
    fragdata(1, rhg, vec4)
    fragdata(2, rhb, vec4)
    fragdata(3, rha, vec4)

    void main(void)
    {
        float outside = clamp(borderscale.z*(abs(texcoord0.z - bordercenter.z) - borderrange.z), 0.0, 1.0);
        vec3 tc = vec3(texcoord0.xy, clamp(texcoord0.z, bordercenter.z - borderrange.z, bordercenter.z + borderrange.z));
        rhr = mix(texture3D(tex3, tc), vec4(0.5, 0.5, 0.5, 0.0), outside);
        rhg = mix(texture3D(tex4, tc), vec4(0.5, 0.5, 0.5, 0.0), outside);
        rhb = mix(texture3D(tex5, tc), vec4(0.5, 0.5, 0.5, 0.0), outside);
        rha = mix(texture3D(tex6, tc), vec4(0.5, 0.5, 0.5, 0.0), outside);
    }
]

lazyshader 0 radiancehintscached [
    attribute vec4 vvertex;
    attribute vec3 vtexcoord0;
    varying vec3 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0;
    }
] [
    uniform sampler3D tex7, tex8, tex9, tex10;
    varying vec3 texcoord0;
    fragdata(0, rhr, vec4)
    fragdata(1, rhg, vec4)
    fragdata(2, rhb, vec4)
    fragdata(3, rha, vec4)

    void main(void)
    {
        rhr = texture3D(tex7, texcoord0);
        rhg = texture3D(tex8, texcoord0);
        rhb = texture3D(tex9, texcoord0);
        rha = texture3D(tex10, texcoord0);
    }
]

lazyshader 0 radiancehintsdisable [
    attribute vec4 vvertex;
    uniform vec3 rhcenter;
    uniform float rhbounds;
    void main(void)
    {
        gl_Position = vec4((vvertex.xy - rhcenter.xy)/rhbounds, vvertex.zw);
    }
] [
    fragdata(0, rhr, vec4)
    fragdata(1, rhg, vec4)
    fragdata(2, rhb, vec4)
    fragdata(3, rha, vec4)

    void main(void)
    {
        rhr = vec4(0.5, 0.5, 0.5, 0.0);
        rhg = vec4(0.5, 0.5, 0.5, 0.0);
        rhb = vec4(0.5, 0.5, 0.5, 0.0);
        rha = vec4(0.5, 0.5, 0.5, 0.0);
    }
]

////////////////////////////////////////////////
//
// deferred shading
//
////////////////////////////////////////////////

lazyshader 0 msaaresolve [
    attribute vec4 vvertex;
    void main(void)
    {
        gl_Position = vvertex;
    }
] [
    uniform sampler2DMS tex0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = texelFetch(tex0, ivec2(gl_FragCoord.xy), 0);
    }
]

lazyshader 0 msaareducew [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 tap0, tap1;
    void main(void)
    {
        gl_Position = vvertex;
        tap0 = vtexcoord0; 
        tap1 = vtexcoord0 + vec2(-1.0, 0.0);
    }
] [
    uniform sampler2DMS tex0; 
    varying vec2 tap0, tap1;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = 0.5*(texelFetch(tex0, ivec2(tap0), 0) + texelFetch(tex0, ivec2(tap1), 0));
    }
]

lazyshader 0 msaareduce [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 tap0, tap1, tap2, tap3;
    void main(void)
    {
        gl_Position = vvertex;
        tap0 = vtexcoord0; 
        tap1 = vtexcoord0 + vec2(-1.0,  0.0);
        tap2 = vtexcoord0 + vec2( 0.0, -1.0);
        tap3 = vtexcoord0 + vec2(-1.0, -1.0);
    }
] [
    uniform sampler2DMS tex0; 
    varying vec2 tap0, tap1, tap2, tap3;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = 0.25*(texelFetch(tex0, ivec2(tap0), 0) + texelFetch(tex0, ivec2(tap1), 0) +
                          texelFetch(tex0, ivec2(tap2), 0) + texelFetch(tex0, ivec2(tap3), 0));
    }
]

msaadetectedges = [
    result [{
        vec4 e = texelFetch(tex1, ivec2(gl_FragCoord.xy), 0);
        e.xyz -= 0.5;
        float maxdiff = 0.98*0.98*dot(e.xyz, e.xyz); 
        @(loopconcat+ i 1 (- $msaasamples 1) [result [
            vec4 e@i = texelFetch(tex1, ivec2(gl_FragCoord.xy), @i);
            e@i.xyz -= 0.5;
            if(abs(e.w-e@i.w) <= 2.0/255.0 && pow(dot(e@i.xyz, e.xyz), 2.0) >= maxdiff*dot(e@i.xyz, e@i.xyz))
            {
        ]])
        @arg1
        @(loopconcat+ i 1 (- $msaasamples 1) [result [
            }
        ]])
    }]
]

lazyshader 0 msaaedgedetect [
    attribute vec4 vvertex;
    void main(void)
    {
        gl_Position = vvertex;
    }
] [
    uniform sampler2DMS tex0, tex1, tex2, tex3;

    void main(void)
    {
        @(msaadetectedges [discard;])
    }
]
    
// deferredlighttype:
//    p -> point-light shadow (default cubemap)
//    c -> CSM
//    a -> AO
//    A -> AO sun
//    r -> radiance hints
//    G -> 5x5 weighted gather filter
//    g -> 3x3 weighted gather filter
//    E -> 5x5 weighted bilinear filter
//    F -> 3x3 weighted bilinear filter
//    f -> 4x rotated grid filter
//    m -> minimap
//    M -> multisampled
//    O -> sample 1
//    R -> manual resolve
//    S -> sample shading
//    T -> edge detection
dlopt = [ >= (strstr $deferredlighttype $arg1) 0 ]

deferredlightvariantshader = [
    deferredlighttype = $arg3
    numsplits = (+ $arg4 0)
    numrh = (+ $arg5 0)
    numlights = (+ $arg6 0)
    baselight = (< (mod $arg2 4) 2)
    spotlight = (>= $arg2 4) 
    variantshader 0 $arg1 $arg2 (? (< $arg2 0) [
        attribute vec4 vvertex;
        uniform mat4 lightmatrix;
        void main(void)
        {
            gl_Position = lightmatrix * vvertex;
        }
    ]) [
        @(if (&& (dlopt "S") [< $glslversion 400]) [result [
            #extension GL_ARB_sample_shading : enable
        ]])
        @(if (&& (|| (dlopt "g") (dlopt "G")) [< $glslversion 400]) [result [
            @(if (> $usetexgather 1) [result [
                #ifdef GL_ARB_gpu_shader5
                #  extension GL_ARB_gpu_shader5 : enable
                #endif
            ]])
            #ifdef GL_ARB_texture_gather
            #  extension GL_ARB_texture_gather : enable
            #else
            #  ifdef GL_AMD_texture_texture4
            #    extension GL_AMD_texture_texture4 : enable
            #  endif
            #endif
        ]])
        @(if (dlopt "M") [result [
            uniform sampler2DMS tex0, tex1, tex2, tex3;
        ]] [result [
            uniform sampler2DRect tex0, tex1, tex2, tex3;
        ]])
        @(if (|| (dlopt "p") (dlopt "c")) [
            if (|| (dlopt "g") (dlopt "G")) [if (> $usetexgather 1) [result [
                uniform sampler2DShadow tex4;
            ]] [result [
                uniform sampler2D tex4;
            ]]] [result [
                uniform sampler2DRectShadow tex4;
            ]]
        ])
        @(if $numlights [result [
            uniform vec4 lightpos[@@numlights];
            uniform vec3 lightcolor[@@numlights];
            @(if $spotlight [result [
                uniform vec4 spotparams[@@numlights];
            ]])
            @(if (dlopt "p") [result [
                uniform vec4 shadowparams[@@numlights];
                uniform vec2 shadowoffset[@@numlights];
            ]])
        ]])
        @(if $numsplits [result [
            uniform vec3 splitcenter[@@numsplits];
            uniform vec3 splitbounds[@@numsplits];
            uniform vec3 splitscale[@@numsplits];
            uniform vec3 splitoffset[@@numsplits];
        ]])
        @(if (dlopt "c") [result [
            uniform mat3 csmmatrix;
            uniform vec3 sunlightdir;
            uniform vec3 sunlightcolor;
            @(if (dlopt "r") [result [
                uniform vec3 skylightcolor;
                uniform float giscale, rhnudge;
                uniform vec4 rhbb[@@numrh];
                uniform vec3 rhscale[@@numrh];
                uniform vec3 rhoffset[@@numrh];
                uniform sampler3D tex6, tex7, tex8, tex9;
            ]])  
        ]])
        uniform vec3 camera;
        uniform mat4 worldmatrix;
        uniform vec4 fogdir;
        uniform vec3 fogcolor;
        uniform vec2 fogdensity;
        uniform vec4 radialfogscale;
        uniform vec2 shadowatlasscale;
        uniform vec4 lightscale;
        @(? (dlopt "a") [uniform sampler2DRect tex5; uniform vec2 aoscale; uniform vec4 aoparams;])
        @(gdepthunpackparams)
        fragdata(0, fragcolor, vec4)

        @(if (dlopt "p") [
            if $spotlight [result [
                vec3 getspottc(vec3 dir, float spotdist, vec4 spotparams, vec4 shadowparams, vec2 shadowoffset)
                {
                    vec2 mparams = shadowparams.xy / spotdist;
                    return vec3((dir.xy - spotparams.xy*(spotdist + dir.z)*shadowparams.z) * mparams.x + shadowoffset, mparams.y + shadowparams.w);
                }
            ]] [result [
                vec3 getshadowtc(vec3 dir, vec4 shadowparams, vec2 shadowoffset)
                {
                    vec3 adir = abs(dir);
                    float m = max(adir.x, adir.y);
                    vec2 mparams = shadowparams.xy / max(adir.z, m);
                    vec4 proj;
                    if(adir.x > adir.y) proj = vec4(dir.zyx, 0.0); else proj = vec4(dir.xzy, 1.0);
                    if(adir.z > m) proj = vec4(dir, 2.0);
                    return vec3(proj.xy * mparams.x + vec2(proj.w, step(proj.z, 0.0)) * shadowparams.z + shadowoffset, mparams.y + shadowparams.w);
                }
            ]]
        ])

        @(if (|| (dlopt "p") (dlopt "c")) [
            cond [dlopt "G"] [result [
                @(if (> $usetexgather 1) [result [
                #define shadowgather(center, xoff, yoff) textureGatherOffset(tex4, center, shadowtc.z, ivec2(xoff, yoff))
                ]] [result [
                #if __VERSION__ >= 400 || defined(GL_ARB_texture_gather)
                #  define shadowgather(center, xoff, yoff) step(shadowtc.z, textureGatherOffset(tex4, center, ivec2(xoff, yoff)))
                #else
                #  define shadowgather(center, xoff, yoff) step(shadowtc.z, texture4(tex4, center + vec2(xoff, yoff)*shadowatlasscale))
                #endif
                ]])
                float filtershadow(vec3 shadowtc)
                {
                    vec2 offset = fract(shadowtc.xy - 0.5), center = (shadowtc.xy - offset)*shadowatlasscale;
                    vec4 group1 = shadowgather(center, -2.0, -2.0);
                    vec4 group2 = shadowgather(center,  0.0, -2.0);
                    vec4 group3 = shadowgather(center,  2.0, -2.0);
                    vec4 group4 = shadowgather(center, -2.0,  0.0);
                    vec4 group5 = shadowgather(center,  0.0,  0.0);
                    vec4 group6 = shadowgather(center,  2.0,  0.0);
                    vec4 group7 = shadowgather(center, -2.0,  2.0);
                    vec4 group8 = shadowgather(center,  0.0,  2.0);
                    vec4 group9 = shadowgather(center,  2.0,  2.0);
                    vec4 locols = vec4(group1.ab, group3.ab);
                    vec4 hicols = vec4(group7.rg, group9.rg);
                    locols.yz += group2.ab;
                    hicols.yz += group8.rg;
                    vec4 midcols = vec4(group1.rg, group3.rg) + vec4(group7.ab, group9.ab) +
                                   vec4(group4.rg, group6.rg) + vec4(group4.ab, group6.ab) +
                                   mix(locols, hicols, offset.y);
                    vec4 cols = group5 + vec4(group2.rg, group8.ab);
                    cols.xyz += mix(midcols.xyz, midcols.yzw, offset.x);
                    return dot(cols, vec4(1.0/25.0));
                }
            ]] [dlopt "g"] [result [
                @(if (> $usetexgather 1) [result [
                #define shadowgather(center, xoff, yoff) textureGatherOffset(tex4, center, shadowtc.z, ivec2(xoff, yoff))
                ]] [result [
                #if __VERSION__ >= 400 || defined(GL_ARB_texture_gather)
                #  define shadowgather(center, xoff, yoff) step(shadowtc.z, textureGatherOffset(tex4, center, ivec2(xoff, yoff)))
                #else
                #  define shadowgather(center, xoff, yoff) step(shadowtc.z, texture4(tex4, center + vec2(xoff, yoff)*shadowatlasscale))
                #endif
                ]])
                float filtershadow(vec3 shadowtc)
                {
                    vec2 offset = fract(shadowtc.xy - 0.5), center = (shadowtc.xy - offset)*shadowatlasscale;
                    vec4 group1 = shadowgather(center, -1.0, -1.0);
                    vec4 group2 = shadowgather(center,  1.0, -1.0);
                    vec4 group3 = shadowgather(center, -1.0,  1.0);
                    vec4 group4 = shadowgather(center,  1.0,  1.0);
                    vec4 cols = vec4(group1.rg, group2.rg) + vec4(group3.ab, group4.ab) + mix(vec4(group1.ab, group2.ab), vec4(group3.rg, group4.rg), offset.y);
                    return dot(mix(cols.xyz, cols.yzw, offset.x), vec3(1.0/9.0));
                }
            ]] [dlopt "E"] [result [
                #define shadowval(xy, xoff, yoff) float(shadow2DRect(tex4, vec3(xy + vec2(xoff, yoff), shadowtc.z)))
                float filtershadow(vec3 shadowtc)
                {
                    vec2 offset = fract(shadowtc.xy - 0.5);
                    vec4 center = vec4(shadowtc.xy - offset + 0.5, shadowtc.xy - offset*0.5);
                    vec4 size = vec4(offset + 1.0, 2.0 - offset);
                    return (1.0/25.0)*dot(size.zxzx*size.wwyy, 
                            vec4(shadowval(center.zw, -1.5, -1.5), 
                                 shadowval(center.zw, 2.0, -1.5), 
                                 shadowval(center.zw, -1.5, 2.0), 
                                 shadowval(center.zw, 2.0, 2.0))) + 
                           (2.0/25.0)*dot(size, 
                            vec4(shadowval(center.zy, 2.0, 0.0), 
                                 shadowval(center.xw, 0.0, 2.0),
                                 shadowval(center.zy, -1.5, 0.0),
                                 shadowval(center.xw, 0.0, -1.5))) +
                           (4.0/25.0)*shadowval(center.xy, 0.0, 0.0);
                }   
            ]] [dlopt "F"] [result [
                #define shadowval(center, xoff, yoff) float(shadow2DRect(tex4, center + vec3(xoff, yoff, 0.0)))
                float filtershadow(vec3 shadowtc)
                {
                    vec2 offset = fract(shadowtc.xy - 0.5);
                    vec3 center = shadowtc;
                    //center.xy -= offset;
                    //vec4 size = vec4(offset + 1.0, 2.0 - offset), weight = vec4(2.0 - 1.0 / size.xy, 1.0 / size.zw - 1.0);
                    //return (1.0/9.0)*dot(size.zxzx*size.wwyy,
                    //    vec4(shadowval(center, weight.zw),
                    //         shadowval(center, weight.xw),
                    //         shadowval(center, weight.zy),
                    //         shadowval(center, weight.xy)));
                    center.xy -= offset*0.5;
                    vec4 size = vec4(offset + 1.0, 2.0 - offset);
                    return (1.0/9.0)*dot(size.zxzx*size.wwyy,
                        vec4(shadowval(center, -0.5, -0.5),
                             shadowval(center, 1.0, -0.5),
                             shadowval(center, -0.5, 1.0),
                             shadowval(center, 1.0, 1.0)));
                }
            ]] [dlopt "f"] [result [
                #define shadowval(center, xoff, yoff) float(shadow2DRect(tex4, center + vec3(xoff, yoff, 0.0)))
                float filtershadow(vec3 shadowtc)
                {
                    return dot(vec4(0.25),
                                vec4(shadowval(shadowtc, -0.4, 1.0),
                                    shadowval(shadowtc, -1.0, -0.4),
                                    shadowval(shadowtc, 0.4, -1.0),
                                    shadowval(shadowtc, 1.0, 0.4))); 
                }
            ]] [result [
                #define filtershadow(shadowtc) float(shadow2DRect(tex4, shadowtc))
            ]]
        ])

        @(if (dlopt "c") [result [
            vec3 getcsmtc(vec3 pos)
            {
                pos = csmmatrix * pos;
                @(loopconcat j (- $numsplits 1) [result [
                    if(all(lessThan(abs(pos - splitcenter[@@j]), splitbounds[@@j])))
                        pos = pos*splitscale[@@j] + splitoffset[@@j];
                    else
                ]])
                if(all(lessThan(abs(pos.xy - splitcenter[@@(- $numsplits 1)].xy), splitbounds[@@(- $numsplits 1)].xy)))
                    pos = pos*splitscale[@@(- $numsplits 1)] + splitoffset[@@(- $numsplits 1)];
                else pos = vec3(-1.0);
                return pos;
            }
            
            @(if (dlopt "r") [result [
                vec4 getrhlight(vec3 pos, vec3 norm)
                {
                    vec3 tc;
                    pos += norm*rhnudge;
                    @(loopconcat j $numrh [result [
                        if(all(lessThan(abs(pos - rhbb[@@j].xyz), vec3(rhbb[@@j].w))))
                            tc = pos*rhscale[@@j] + rhoffset[@@j];
                        else
                    ]])
                        tc = vec3(-1.0);
                    vec4 shr = texture3D(tex6, tc), shg = texture3D(tex7, tc), shb = texture3D(tex8, tc), sha = texture3D(tex9, tc);
                    shr.rgb -= 0.5;
                    shg.rgb -= 0.5;
                    shb.rgb -= 0.5;
                    sha.rgb -= 0.5;
                    vec4 basis = vec4(norm*-(1.023326*0.488603/3.14159*2.0), (0.886226*0.282095/3.14159));
                    return clamp(vec4(dot(basis, shr), dot(basis, shg), dot(basis, shb), min(dot(basis, sha), norm.z + 1.0)), 0.0, 1.0);
                }
            ]])
        ]])
            
        void main(void)
        {
            @(if (dlopt "M") [
                if (dlopt "R") [result [
                    @(if (dlopt "T") [result [
                        bool shouldresolve = true;
                        @(msaadetectedges [shouldresolve = false;])
                    ]])

                    #define gfetch(sampler, coords) texelFetch(sampler, ivec2(coords), sampleidx)

                    vec4 resolved = vec4(0.0);
                    #define accumlight(light) resolved.rgb += light
                    #define accumalpha(alpha) resolved.a += alpha

                    @(if (&& $baselight [dlopt "a"]) [result [
                        float ao = texture2DRect(tex5, gl_FragCoord.xy*aoscale).r;
                    ]])

                    for(int sampleidx = 0; sampleidx < @msaasamples; sampleidx++) 
                    {
                ]] [result [
                    @(if (dlopt "T") [msaadetectedges [discard;]])

                    #define gfetch(sampler, coords) texelFetch(sampler, ivec2(coords), @(? (dlopt "S") [gl_SampleID] (? (dlopt "O") 1 0)))

                    #define accumlight(light) fragcolor.rgb = light
                    #define accumalpha(alpha) fragcolor.a = alpha
                ]]
            ] [result [
                #define gfetch(sampler, coords) texture2DRect(sampler, coords)

                #define accumlight(light) fragcolor.rgb = light
                #define accumalpha(alpha) fragcolor.a = alpha
            ]])

            @(if (|| (> $numlights 0) (dlopt "c")) [result [
                @(gdepthunpack depth [gfetch(tex3, gl_FragCoord.xy)] [
                    @(? (dlopt "m") [
                        vec3 pos = (worldmatrix * vec4(gl_FragCoord.xy, depth, 1.0)).xyz;
                    ] [
                        vec3 pos = (worldmatrix * vec4(depth*gl_FragCoord.xy, depth, 1.0)).xyz;
                    ])
                ] [
                    vec4 pos = worldmatrix * vec4(gl_FragCoord.xy, depth, 1.0);
                    pos.xyz /= pos.w;
                ])
                @(? (|| (dlopt "c") [> $numlights 1]) [
                    vec4 normal = gfetch(tex1, gl_FragCoord.xy);
                    normal.xyz = normal.xyz*2.0 - 1.0;
                ])
                @(? (&& (|| $baselight [> $numlights 1]) [! (dlopt "m")]) [
                    float fogcoord = length(camera - pos.xyz);
                ])
                @(? (&& (> (+ $numlights (dlopt "c")) 1) [! (dlopt "m")]) [
                    vec3 camdir = normalize(camera - pos.xyz);
                    float facing = 2.0*dot(normal.xyz, camdir);
                ])
            ]] [if (! (dlopt "m")) [result [
                @(gdepthunpack depth [gfetch(tex3, gl_FragCoord.xy)])
                #define fogcoord -depth*length(vec3(gl_FragCoord.xy*radialfogscale.xy + radialfogscale.zw, 1.0))
            ]]])

            @(? (|| $baselight [> $numlights 1]) [
                vec4 diffuse = gfetch(tex0, gl_FragCoord.xy);
            ])
            @(if $baselight [result [
                vec3 light = lightscale.rgb;
                @(? (dlopt "r") [
                    vec4 rhlight = getrhlight(pos.xyz, normal.xyz); 
                    light += rhlight.a * skylightcolor;
                ])
                light *= diffuse.rgb;
                @(if (dlopt "a") [
                    ? (&& (dlopt "M") [dlopt "R"]) [
                        light *= aoparams.x + ao*aoparams.y;
                    ] [
                        float ao = texture2DRect(tex5, gl_FragCoord.xy*aoscale).r;
                        light *= aoparams.x + ao*aoparams.y;
                    ]
                ])
                vec4 glow = gfetch(tex2, gl_FragCoord.xy);
                light += glow.rgb * lightscale.a;
            ]] [result [
                vec3 light = vec3(0.0);
            ]])

            @(if (dlopt "c") [result [
                @(? (dlopt "r") [
                    vec3 sunlight = rhlight.rgb * giscale * diffuse.rgb;
                ])
                float sunfacing = dot(sunlightdir, normal.xyz);
                if(sunfacing > 0.0)
                {
                    vec3 csmtc = getcsmtc(pos.xyz);
                    float sunoccluded = sunfacing * filtershadow(csmtc);
                    @(if (dlopt "m") [result [
                        light += diffuse.rgb * sunlightcolor * sunoccluded;
                    ]] [result [
                        @(? (= (+ $numlights (dlopt "c")) 1) [
                            vec3 camdir = normalize(camera - pos.xyz);
                            float facing = 2.0*dot(normal.xyz, camdir);
                        ])
                        float sunspec = pow(clamp(sunfacing*facing - dot(camdir, sunlightdir), 0.0, 1.0), 16.0) * diffuse.a;
                        @(if (dlopt "r") [result [
                            sunlight += (diffuse.rgb + sunspec) * sunoccluded;
                        ]] [result [
                            @(? (dlopt "A") [
                                sunoccluded *= aoparams.z + ao*aoparams.w;
                            ])
                            light += (diffuse.rgb + sunspec) * sunoccluded * sunlightcolor;
                        ]])
                    ]])
                }
                @(if (dlopt "r") [result [
                    @(? (dlopt "A") [
                        sunlight *= aoparams.z + ao*aoparams.w;
                    ])
                    light += sunlight * sunlightcolor;
                ]])
            ]])

            @(loopconcat j $numlights [result [
                vec3 light@[j]dir = pos.xyz * lightpos[@@j].w - lightpos[@@j].xyz;
                float light@[j]dist2 = dot(light@[j]dir, light@[j]dir);
                if(light@[j]dist2 < 1.0)
                {
                    @(? (&& (= $numlights 1) [! (dlopt "c")]) [
                        vec4 normal = gfetch(tex1, gl_FragCoord.xy);
                        normal.xyz = normal.xyz*2.0 - 1.0;
                    ])
                    float light@[j]facing = dot(light@[j]dir, normal.xyz);
                    if(light@[j]facing < 0.0) 
                    {
                        float light@[j]invdist = inversesqrt(light@[j]dist2); 
                        @(if $spotlight [result [
                            float spot@[j]dist = dot(light@[j]dir, spotparams[@@j].xyz);
                            float spot@[j]atten = 1.0 - (1.0 - light@[j]invdist * spot@[j]dist) * spotparams[@@j].w;
                            if(spot@[j]atten > 0.0)
                            {
                        ]])
                        float light@[j]atten = light@[j]facing * (1.0 - light@[j]invdist);
                        @(if $spotlight [
                            if (dlopt "p") [result [
                                vec3 spot@[j]tc = getspottc(light@[j]dir, spot@[j]dist, spotparams[@@j], shadowparams[@@j], shadowoffset[@@j]);
                                light@[j]atten *= spot@[j]atten * filtershadow(spot@[j]tc);
                            ]] [result [
                                light@[j]atten *= spot@[j]atten;
                            ]]
                        ] [
                            if (dlopt "p") [result [
                                vec3 shadow@[j]tc = getshadowtc(light@[j]dir, shadowparams[@@j], shadowoffset[@@j]);
                                light@[j]atten *= filtershadow(shadow@[j]tc);
                            ]]
                        ])
                        @(? (&& (= $numlights 1) [! $baselight]) [
                            vec4 diffuse = gfetch(tex0, gl_FragCoord.xy);
                        ])
                        @(if (dlopt "m") [result [
                            light += diffuse.rgb * lightcolor[@@j] * light@[j]atten;
                        ]] [result [
                            @(? (= (+ $numlights (dlopt "c")) 1) [
                                vec3 camdir = normalize(camera - pos.xyz);
                                float facing = 2.0*dot(normal.xyz, camdir);
                            ])
                            float light@[j]spec = pow(clamp(light@[j]invdist*(dot(camdir, light@[j]dir) - light@[j]facing*facing), 0.0, 1.0), 16.0) * diffuse.a;
                            light += (diffuse.rgb + light@[j]spec) * lightcolor[@@j] * light@[j]atten;
                            @(? (= (+ $numlights $baselight) 1) [
                                float fogcoord = length(camera - pos.xyz);
                                float foglerp = clamp(exp2(fogcoord*fogdensity.x)*fogdensity.y, 0.0, 1.0);
                                light *= foglerp;
                            ])
                        ]])
                        @(? $spotlight [}]) 
                    }
                }
            ]])
            @(if (dlopt "m") [if $baselight [result [
                accumlight(light);
                accumalpha(glow.a);
            ]] [result [
                accumlight(light);
                accumalpha(0.0);
            ]]] [if (|| $baselight [> $numlights 1]) [result [
                float foglerp = clamp(exp2(fogcoord*fogdensity.x)*fogdensity.y, 0.0, 1.0);
                @(? $baselight [
                    accumlight(mix(fogcolor*glow.a, light, foglerp));
                    accumalpha(glow.a);
                ] [
                    accumlight(light*foglerp);
                    accumalpha(0.0);
                ])
            ]] [result [
                accumlight(light);
                accumalpha(0.0);
            ]]])

            @(if (dlopt "R") [result [
                    @(? (dlopt "T") [if(!shouldresolve) break;])
                }

                @(? (dlopt "T") [if(shouldresolve)]) resolved *= @(divf 1 $msaasamples);
                fragcolor = resolved;
            ]])
        }
    ] $arg7
]

deferredlightshader = [
    shadername = (concatword "deferredlight" $arg1 $arg2 $arg3)
    maxvariants = (* (max $arg6 1) (? $arg7 8 4))
    deferredlightvariantshader $shadername -1 (concatword $arg1 $arg3) $arg4 $arg5 0 $maxvariants // base shader, no points lights, sunlight
    loop+ i 1 (max $arg6 1) [
        if $arg7 [
            deferredlightvariantshader $shadername 0 (concatword $arg1 $arg3) $arg4 $arg5 $i $maxvariants // row 0, point lights, sunlight
            deferredlightvariantshader $shadername 1 (concatword $arg1 $arg2 $arg3) $arg4 $arg5 $i $maxvariants // row 1, shadowed point lights, sunlight
        ]
        deferredlightvariantshader $shadername 2 $arg1 $arg4 $arg5 $i $maxvariants // row 2, point lights 
        deferredlightvariantshader $shadername 3 (concatword $arg1 $arg2) $arg4 $arg5 $i $maxvariants // row 3, shadowed point lights
        if $arg7 [
            deferredlightvariantshader $shadername 4 (concatword $arg1 $arg3) $arg4 $arg5 $i $maxvariants // row 4, spot lights, sunlight
            deferredlightvariantshader $shadername 5 (concatword $arg1 $arg2 $arg3) $arg4 $arg5 $i $maxvariants // row 5, shadowed spot lights, sunlight
        ]
        deferredlightvariantshader $shadername 6 $arg1 $arg4 $arg5 $i $maxvariants // row 6, spot lights 
        deferredlightvariantshader $shadername 7 (concatword $arg1 $arg2) $arg4 $arg5 $i $maxvariants // row 7, shadowed spot lights
    ]
]

lazyshader 0 "modelpreview" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;

    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
    }
] [
    @(gfetchdefs [tex0 tex1 tex2 tex3])
    uniform vec3 camera;
    uniform mat4 worldmatrix;
    uniform vec4 lightscale;
    uniform vec3 sunlightdir;
    uniform vec3 sunlightcolor;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)

    void main(void)
    {
        vec4 diffuse = gfetch(tex0, texcoord0);    
        vec3 light = diffuse.rgb * lightscale.rgb;
        vec4 glow = gfetch(tex2, texcoord0);
        light += glow.rgb * lightscale.a;

        vec4 normal = gfetch(tex1, texcoord0);
        normal.xyz = normal.xyz*2.0 - 1.0;

        float sunfacing = dot(sunlightdir, normal.xyz);
        if(sunfacing > 0.0)
        {
            @(gdepthunpack depth [gfetch(tex3, texcoord0)] [
                vec3 pos = (worldmatrix * vec4(depth*texcoord0, depth, 1.0)).xyz;
            ] [
                vec4 pos = worldmatrix * vec4(texcoord0, depth, 1.0);
                pos.xyz /= pos.w;
            ])
            vec3 camdir = normalize(camera - pos.xyz);
            float facing = 2.0*dot(normal.xyz, camdir);
            float sunspec = pow(clamp(sunfacing*facing - dot(camdir, sunlightdir), 0.0, 1.0), 8.0) * diffuse.a;
            light += (diffuse.rgb + sunspec) * sunfacing * sunlightcolor;
        }

        fragcolor.rgb = light;
        fragcolor.a = glow.a;
    }
]

shader 0 "hdrreduce" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
    }
] [
    uniform sampler2DRect tex0; 
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor.rgb = texture2DRect(tex0, texcoord0).rgb;
    }
]

shader 0 "hdrreduce2w" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0;
    }
] [
    uniform sampler2DRect tex0; 
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor.rgb = 0.5*(texture2DRectOffset(tex0, texcoord0, ivec2(-1, 0)).rgb + texture2DRectOffset(tex0, texcoord0, ivec2(1, 0)).rgb);
    }
]

shader 0 "hdrreduce2" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0;
    }
] [
    uniform sampler2DRect tex0; 
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor.rgb = 0.25*(texture2DRectOffset(tex0, texcoord0, ivec2(-1, -1)).rgb + texture2DRectOffset(tex0, texcoord0, ivec2(1, -1)).rgb +
                              texture2DRectOffset(tex0, texcoord0, ivec2(1, 1)).rgb + texture2DRectOffset(tex0, texcoord0, ivec2(-1, 1)).rgb);
    }
]

lumweights = "0.2126, 0.7152, 0.0722"
//lumweights = "0.299, 0.587, 0.114"

hdrgammadecode = [
    if (=f $hdrgamma 2) [result [
        @arg1 *= @arg1;
    ]] [result [
        @arg1 = pow(@arg1, vec3(hdrgamma.x));
    ]]
]

hdrgammaencode = [
    if (=f $hdrgamma 2) [result [
        @arg1 = sqrt(@arg1);
    ]] [result [
        @arg1 = pow(@arg1, vec3(hdrgamma.y));
    ]]
]

shader 0 "hdrluminance" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
    }
] [
    uniform sampler2DRect tex0; 
    uniform vec2 hdrgamma;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec3 color = texture2DRect(tex0, texcoord0).rgb*2.0;
        @(hdrgammadecode color)
        float lum = dot(color, vec3(@lumweights));
        float loglum = sqrt(clamp(lum, 0.015625, 4.0)) * (1.0/2.0); // allow values as low as 2^-6, and as high 2^2
        fragcolor.rgb = vec3(loglum);
    }
]

shader 0 "hdrluminance2w" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0;
    }
] [
    uniform sampler2DRect tex0; 
    uniform vec2 hdrgamma;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        @(loopconcat i 2 [result [
            vec3 color@[i] = texture2DRectOffset(tex0, texcoord0, ivec2(@(at ["-1, 0" "1, 0"] $i))).rgb*2.0;
            @(hdrgammadecode [color@[i]])
            float lum@[i] = dot(color@[i], vec3(@lumweights));
            float loglum@[i] = sqrt(clamp(lum@[i], 0.015625, 4.0)) * (1.0/2.0);
        ]])
        fragcolor.rgb = vec3(0.5*(loglum0 + loglum1));
    }
]

shader 0 "hdrluminance2" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0;
    }
] [
    uniform sampler2DRect tex0; 
    uniform vec2 hdrgamma;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        @(loopconcat i 4 [result [
            vec3 color@[i] = texture2DRectOffset(tex0, texcoord0, ivec2(@(at ["-1, -1" "1, -1" "1, 1" "-1, 1"] $i))).rgb*2.0;
            @(hdrgammadecode [color@[i]])
            float lum@[i] = dot(color@[i], vec3(@lumweights));
            float loglum@[i] = sqrt(clamp(lum@[i], 0.015625, 4.0)) * (1.0/2.0);
        ]])
        fragcolor.rgb = vec3(0.25*(loglum0 + loglum1 + loglum2 + loglum3));
    }
]

shader 0 "hdraccum" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
    }
] [
    uniform sampler2DRect tex0;
    uniform float accumscale;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        float lum = texture2DRect(tex0, texcoord0).r * 2.0;
        lum *= lum;
        fragcolor = vec4(vec3(lum*0.25), accumscale);
    }
]

shader 0 "hdrbloom" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    uniform sampler2D tex2; 
    uniform vec4 hdrparams;
    varying vec2 texcoord0;
    varying float lumscale, lumthreshold;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
        float avglum = 4.0*texture2D(tex2, vec2(0.5, 0.5)).r;
        lumscale = hdrparams.x * -log2(1.0 - clamp(avglum, 0.03, 0.3))/(avglum + 1e-4);
        lumthreshold = -log2(1.0 - hdrparams.z);
    }
] [
    uniform sampler2DRect tex0; 
    uniform vec2 hdrgamma;
    varying vec2 texcoord0;
    varying float lumscale, lumthreshold;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec3 color = texture2DRect(tex0, texcoord0).rgb*2.0;
        @(hdrgammadecode color)
        float lum = dot(color, vec3(@lumweights));
        color *= max(lum*lumscale - lumthreshold, 0.0) / (lum + 1e-4);
        @(hdrgammaencode color)
        fragcolor.rgb = color;
    }
]

hdrtonemapvertexshader = [
  result [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0, vtexcoord1;
    uniform sampler2D tex2; 
    uniform vec4 hdrparams;
    varying vec2 texcoord0, texcoord1;
    varying float lumscale, lumsaturate;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
        texcoord1 = vtexcoord1;
        float avglum = 4.0*texture2D(tex2, vec2(0.5, 0.5)).r;
        lumscale = hdrparams.x * -log2(1.0 - clamp(avglum, 0.03, 0.3))/(avglum + 1e-4);
        lumsaturate = -log2(1.0 - hdrparams.y) / lumscale;
    }
  ]
]

hdrtonemapfrag = [
    result [{
        // color = 1.0 - exp2(-color*lumscale);
        float lum = dot(@arg1, vec3(@lumweights));
        @arg1 = min(@arg1, lumsaturate);
        @arg1 *= (1.0 - exp2(-lum*lumscale)) / (dot(@arg1, vec3(@lumweights)) + 1e-4);
    }]
]

hdrtonemapdefs = [
    result [
        uniform vec4 hdrparams;
        uniform vec2 hdrgamma;
        varying vec2 texcoord0, texcoord1;
        varying float lumscale, lumsaturate;
    ]
]

hdrtonemapshaders = [
  (? $arg1 lazyshader shader) 0 [hdrnop@arg1] [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
    }
  ] [
    @arg2
    uniform sampler2DRect tex0;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec3 color = texture2DRect(tex0, texcoord0).rgb;
        fragcolor.rgb = color;
        @arg4
        @(? $arg3 $arg3 [fragcolor.a = 0.0;])
    }
  ]

  
  (? $arg1 lazyshader shader) 0 [hdrtonemap@arg1] (hdrtonemapvertexshader) [
    @arg2
    uniform sampler2DRect tex0, tex1;
    @(hdrtonemapdefs)
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec3 bloom = texture2DRect(tex1, texcoord1).rgb*hdrparams.w;
        vec3 color = texture2DRect(tex0, texcoord0).rgb*2.0;
        color += bloom;
        @(hdrgammadecode color)
        @(hdrtonemapfrag color)
        @(hdrgammaencode color)
        fragcolor.rgb = color;
        @arg4
        @(? $arg3 $arg3 [fragcolor.a = 0.0;])
    }
  ]
  
  if $msaasamples [msaatonemapshaders $arg1 $arg2 $arg3 $arg4]
  if (= $msaasamples 2) [msaasplitshaders $arg1 $arg2 $arg3 $arg4]
]

msaatonemapshaders = [
  if (=s $arg1 "") [lazyshader 0 [msaatonemapsample] (hdrtonemapvertexshader) [
    #extension GL_ARB_sample_shading : enable
    uniform sampler2DRect tex1;
    uniform sampler2DMS tex0;
    @(hdrtonemapdefs)
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec3 bloom = texture2DRect(tex1, texcoord1).rgb*hdrparams.w;
        vec3 color = texelFetch(tex0, ivec2(texcoord0), gl_SampleID).rgb*2.0;
        color += bloom;
        @(hdrgammadecode color)
        @(hdrtonemapfrag color)
        @(hdrgammaencode color)
        fragcolor = vec4(color, 0.0);
    }
  ]]

  lazyshader 0 [msaatonemap@arg1] (hdrtonemapvertexshader) [
    @arg2
    uniform sampler2DRect tex1;
    uniform sampler2DMS tex0;
    @(hdrtonemapdefs)
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec3 bloom = texture2DRect(tex1, texcoord1).rgb*hdrparams.w;
        vec3 resolved = vec3(0.0);
        for(int sampleidx = 0; sampleidx < @msaasamples; sampleidx++)
        {
            vec3 color = texelFetch(tex0, ivec2(texcoord0), sampleidx).rgb*2.0;
            color += bloom;
            @(hdrgammadecode color)
            @(hdrtonemapfrag color)
            @(hdrgammaencode color)
            resolved += color;
        }
        fragcolor.rgb = resolved * @(divf 1 $msaasamples);
        @arg4
        @(? $arg3 $arg3 [fragcolor.a = 0.0;])
    }
  ]
]

msaasplitshaders = [
  lazyshader 0 [msaatonemapsplit@arg1] (hdrtonemapvertexshader) [
    @arg2
    uniform sampler2DRect tex1;
    uniform sampler2DMS tex0;
    @(hdrtonemapdefs)
    @(loopconcat i $msaasamples [result [
        fragdata(@i, fragdata@i, vec4)
    ]])
    void main(void)
    {
        vec3 bloom = texture2DRect(tex1, texcoord1).rgb*hdrparams.w;
        @arg4
        @(loopconcat i $msaasamples [result [
            vec3 color@i = texelFetch(tex0, ivec2(texcoord0), @i).rgb*2.0 + bloom;
            @(hdrgammadecode [color@i])
            @(hdrtonemapfrag [color@i])
            @(hdrgammaencode [color@i])
            fragdata@i.rgb = color@i;
            @(if $arg3 [result [
                @(strreplace $arg3 [fragcolor] [fragdata@i])
            ]] [result [
                fragdata@i.a = 0.0;
            ]])
        ]])
    }
  ]
]

hdrtonemapshaders ""
hdrtonemapshaders "luma" [] [fragcolor.a = dot(fragcolor.rgb, vec3(@lumweights));]
hdrtonemapshaders "velocity" [
    @(gfetchdefs tex3)
    uniform mat4 reprojectmatrix;
    uniform vec2 maxvelocity;
] [
    fragcolor.a = velocity;
] [
    @(gdepthunpack depth [gfetch(tex3, texcoord0)] [
        vec4 prevtc = reprojectmatrix * vec4(depth*texcoord0, depth, 1.0);
    ] [
        vec4 prevtc = reprojectmatrix * vec4(texcoord0, depth, 1.0);
    ])
    float velocity = distance(prevtc.xy/prevtc.w, texcoord0)*maxvelocity.y;
]
hdrtonemapshaders "velocitymasked" [
    @(gfetchdefs (? (= $gdepthformat 1) [tex3] [tex3 tex4]))
    uniform mat4 reprojectmatrix;
    uniform vec2 maxvelocity;
] [
    fragcolor.a = velocity;
] [
    @(if (= $gdepthformat 1) [result [
        vec4 packdepth = gfetch(tex3, texcoord0);
        float depth = dot(packdepth.rgb, gdepthunpackparams);
        #define mask packdepth.a
        vec4 prevtc = reprojectmatrix * vec4(depth*texcoord0, depth, 1.0);
    ]] [result [
        @(gdepthunpack depth [gfetch(tex3, texcoord0)] [
            vec4 prevtc = reprojectmatrix * vec4(depth*texcoord0, depth, 1.0);
        ] [
            vec4 prevtc = reprojectmatrix * vec4(texcoord0, depth, 1.0);
        ])
        float mask = gfetch(tex4, texcoord0).a;
        @(? $msaasamples [mask = step(0.75, mask);])
    ]])
    float velocity = distance(prevtc.xy/prevtc.w, texcoord0)*maxvelocity.y*(1.0-mask);
]

shader 0 "scalelinear" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;

    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
    }
] [
    uniform sampler2DRect tex0;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)

    void main(void)
    {
        fragcolor = texture2DRect(tex0, texcoord0);
    }
]

loop i 2 [
  lazyshader 0 (? $i "scalecubicy" "scalecubicx") [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;

    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
    }
  ] [
    uniform sampler2DRect tex0;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)

    vec4 cubic(float s)
    {
        const float B = @gscalecubicsoft, C = @(divf (-f 1 $gscalecubicsoft) 2);
        float s2 = s*s, s3 = s2*s;
        return vec4((-1.0/6.0*B - C) * s3 + (0.5*B + 2.0*C) * s2 + (-0.5*B - C) * s + 1.0/6.0*B,
                    (2.0 - 1.5*B - C) * s3 + (-3.0 + 2.0*B + C) * s2 + (1.0 - 1.0/3.0*B),
                    (-2.0 + 1.5*B + C) * s3 + (3.0 - 2.5*B - 2.0*C) * s2 + (0.5*B + C)*s + 1.0/6.0*B,
                    (1.0/6.0*B + C) * s3 - C * s2);
    }

    void main(void)
    {
        vec2 center = texcoord0;
        @(if $i [result [
            float offset = fract(texcoord0.y-0.5);
            center.y -= offset;
            #define texval(tap) texture2DRect(tex0, center + vec2(0.0, tap))
            #define texvaloffset(tap) texture2DRectOffset(tex0, center, ivec2(0, tap))
        ]] [result [
            float offset = fract(texcoord0.x-0.5);
            center.x -= offset;
            #define texval(tap) texture2DRect(tex0, center + vec2(tap, 0.0))
            #define texvaloffset(tap) texture2DRectOffset(tex0, center, ivec2(tap, 0))
        ]])
        vec4 weight = cubic(offset);
        weight.y += weight.z;
        weight.z /= weight.y;
        fragcolor = weight.x*texvaloffset(-1) + weight.y*texval(weight.z) + weight.w*texvaloffset(2);
    }
  ]
]

aotapoffsets = [
"-0.933103, 0.025116"
"-0.432784, -0.989868"
"0.432416, -0.413800"
"-0.117770, 0.970336"
"0.837276, 0.531114"
"-0.184912, 0.200232"
"-0.955748, 0.815118"
"0.946166, -0.998596"
"-0.897519, -0.581102"
"0.979248, -0.046602"
"-0.155736, -0.488204"
"0.460310, 0.982178"
]

ambientobscurancevariantshader = [
    lineardepth = (>= (strstr $arg2 "l") 0)
    packeddepth = (>= (strstr $arg2 "p") 0)
    derivnormal = (>= (strstr $arg2 "d") 0)
    maxaotaps = $arg3 
    shader 0 $arg1 [
        attribute vec4 vvertex;
        attribute vec2 vtexcoord0, vtexcoord1;
        varying vec2 texcoord0, texcoord1;
        void main(void)
        {
            gl_Position = vvertex;
            texcoord0 = vtexcoord0; 
            texcoord1 = vtexcoord1;
        }
    ] [
        @(gfetchdefs tex0 (&& $msaasamples [! $lineardepth]) gdepthfetch)
        @(gfetchdefs tex1 $msaasamples gnormfetch)
        @(gdepthunpackparams)
        uniform sampler2D tex2;
        uniform vec3 tapparams;
        uniform vec2 contrastparams;
        uniform vec4 offsetscale;
        uniform float prefilterdepth;
        @(? (! $derivnormal) [
            uniform mat3 normalmatrix;
        ])
        @(? $lineardepth [
            #define depthtc gl_FragCoord.xy
        ] [
            #define depthtc texcoord0
        ])
        uniform vec3 gdepthpackparams;
        varying vec2 texcoord0, texcoord1;
        fragdata(0, fragcolor, vec4)
        void main(void)
        {
            @(if (&& $derivnormal [= $aodepthformat 1]) [result [
                @(gdepthunpack depth [gnormfetch(tex1, texcoord0)] [
                    vec2 tapscale = tapparams.xy/depth;
                ] [
                    float w = depth*gdepthscale.y + gdepthscale.z;
                    depth = gdepthscale.x/w;
                    vec2 tapscale = tapparams.xy*w;
                ])
            ]] [result [
                @(gdepthunpack depth [gdepthfetch(tex0, depthtc)] [
                    vec2 tapscale = tapparams.xy/depth;
                ] [
                    float w = depth*gdepthscale.y + gdepthscale.z;
                    depth = gdepthscale.x/w;
                    vec2 tapscale = tapparams.xy*w;
                ] $lineardepth (? $lineardepth (! $aodepthformat) (= $gdepthformat 1)) packdepth)
            ]])
            vec2 dpos = depthtc*offsetscale.xy + offsetscale.zw, pos = depth*dpos;
            @(if $derivnormal [result [
                vec2 ddepth = vec2(dFdx(depth), dFdy(depth)); 
                ddepth *= step(abs(ddepth), vec2(4.0));
                vec3 normal;
                normal.xy = (depth+ddepth.yx)*offsetscale.yx;
                normal.z = normal.x*normal.y;
                normal.xy *= -ddepth;
                normal.z -= dot(dpos, normal.xy);
                normal = normalize(normal);
            ]] [result [
                vec3 normal = gnormfetch(tex1, texcoord0).rgb*2.0 - 1.0;
                normal = normalmatrix * normal;
            ]])
            vec2 noise = texture2D(tex2, texcoord1).rg*2.0-1.0;
            float obscure = 0.0;
            @(loopconcat i $maxaotaps [result [
                vec2 offset@[i] = reflect(vec2(@(at $aotapoffsets $i)), noise);
                offset@[i] = depthtc + tapscale * offset@[i];
                @(gdepthunpack [depth@[i]] [gdepthfetch(tex0, offset@[i])] [] [] $lineardepth (&& $lineardepth (! $aodepthformat)))
                vec3 v@[i] = vec3(depth@[i]*(offset@[i]*offsetscale.xy + offsetscale.zw) - pos, depth@[i] - depth);
                float dist2@[i] = dot(v@[i], v@[i]);
                obscure += step(dist2@[i], tapparams.z) * max(0.0, dot(v@[i], normal) + depth*1.0e-2) / (dist2@[i] + 1.0e-5);
            ]])
            obscure = pow(clamp(1.0 - contrastparams.x*obscure, 0.0, 1.0), contrastparams.y);
            @(if $derivnormal [result [
                vec2 weights = step(abs(ddepth), vec2(prefilterdepth)) * (2.0*fract((gl_FragCoord.xy - 0.5)*0.5) - 0.5);
            ]] [result [
                vec2 weights = step(fwidth(depth), prefilterdepth) * (2.0*fract((gl_FragCoord.xy - 0.5)*0.5) - 0.5);
            ]])
            obscure -= dFdx(obscure) * weights.x;
            obscure -= dFdy(obscure) * weights.y;
            @(if $packeddepth [
                if $aodepthformat [result [
                    fragcolor.rg = vec2(obscure, depth);
                ]] [result [
                    @(if (&& (! $lineardepth) (!= $gdepthformat 1)) [gpackdepth packdepth depth])
                    fragcolor = vec4(packdepth, obscure);
                ]]
            ] [result [
                fragcolor = vec4(obscure, 0.0, 0.0, 1.0);
            ]])
        }
    ]
]

ambientobscuranceshader = [
    ambientobscurancevariantshader (format "ambientobscurance%1%2" $arg1 $arg2) $arg1 $arg2
]

shader 0 "linearizedepth" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
    }
] [
    @(gfetchdefs tex0)
    uniform vec3 gdepthpackparams;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        @(if (! $aodepthformat) [
            if (= $gdepthformat 1) [result [
                fragcolor = gfetch(tex0, texcoord0);
            ]] [result [
                @(gdepthunpack depth [gfetch(tex0, texcoord0)])
                @(gpackdepth packdepth depth)
                fragcolor = vec4(packdepth, 1.0);
            ]]    
        ] [result [
            @(gdepthunpack depth [gfetch(tex0, texcoord0)])
            fragcolor.r = depth;
        ]])
    }
] 

bilateralvariantshader = [
    linear = (>= (strstr $arg2 "l") 0)
    packed = (>= (strstr $arg2 "p") 0)
    upscaled = (>= (strstr $arg2 "u") 0)
    numtaps = $arg3
    reduced = $arg4
    filterdir = $arg5
    shader 0 $arg1 [
        attribute vec4 vvertex;
        @(? $reduced [attribute vec2 vtexcoord0; varying vec2 texcoord0;])
        @(? $upscaled [attribute vec2 vtexcoord1; varying vec2 texcoord1;])
        void main(void)
        {
            gl_Position = vvertex;
            @(? $reduced [texcoord0 = vtexcoord0;])
            @(? $upscaled [texcoord1 = vtexcoord1;])
        }
    ] [
        @(gfetchdefs tex1 (&& $msaasamples [! $linear]))
        uniform sampler2DRect tex0;
        uniform vec2 bilateralparams;
        uniform vec3 gdepthpackparams;
        @(? $reduced [varying vec2 texcoord0;])
        @(? $upscaled [varying vec2 texcoord1;])
        fragdata(0, fragcolor, vec4)
        void main(void)
        {
            #define tc @(? $upscaled [texcoord1] [gl_FragCoord.xy])
            #define depthtc @(? $reduced [texcoord0] [gl_FragCoord.xy])
            #define tapvec(type, i) @(? (=s $filterdir "x") [type(i, 0.0)] [type(0.0, i)])
            #define texval(i) texture2DRect(tex0, tc + tapvec(vec2, i))
            #define texvaloffset(i) texture2DRectOffset(tex0, tc, tapvec(ivec2, i))
            #define depthval(i) gfetch(tex1, depthtc + tapvec(vec2, i))
            #define depthvaloffset(i) gfetchoffset(tex1, depthtc, tapvec(ivec2, i))
            @(cond [$packed] [
                if $aodepthformat [result [
                    vec2 vals = texture2DRect(tex0, tc).rg;
                    #define color vals.x
                    @(if $upscaled [gdepthunpack depth [gfetch(tex1, depthtc)]] [result [
                        #define depth vals.y
                    ]])
                ]] [result [
                    vec4 vals = texture2DRect(tex0, tc);
                    #define color vals.a
                    @(if $upscaled [gdepthunpack depth [gfetch(tex1, depthtc)]] [result [
                        float depth = dot(vals.rgb, gdepthunpackparams);
                    ]])                 
                ]]
            ] [$linear] [result [
                float color = gfetch(tex0, tc).r;
                @(if $aodepthformat [result [
                    float depth = gfetch(tex1, depthtc).r;
                ]] [result [
                    float depth = dot(gfetch(tex1, depthtc).rgb, gdepthunpackparams);
                ]])
            ]] [result [
                float color = texture2DRect(tex0, tc).r;
                @(gdepthunpack depth [gfetch(tex1, depthtc)])
            ]])
            float weights = 1.0;
            @(loopconcat i (* 2 $numtaps) [
                curtap = (- $i $numtaps)
                if (>= $curtap 0) [curtap = (+ $curtap 1)]
                curtapoffset = (* $curtap 2)
                curdepthoffset = (<< $curtapoffset $reduced)
                curtexval = [texval@(? (<= $mintexrectoffset $curtapoffset $maxtexrectoffset) "offset")(@(+f $curtapoffset))]
                curdepthval = [depthval@(? (<= $mintexrectoffset $curdepthoffset $maxtexrectoffset) "offset")(@(+f $curdepthoffset))]
                result [
                    @(cond [$packed] [
                        if $aodepthformat [result [
                            vec2 vals@[i] = @[curtexval].rg;
                            #define color@[i] vals@[i].x
                            #define depth@[i] vals@[i].y
                        ]] [result [
                            vec4 vals@[i] = @[curtexval];
                            #define color@[i] vals@[i].a
                            float depth@[i] = dot(vals@[i].rgb, gdepthunpackparams);                 
                        ]]
                    ] [$linear] [
                        result [
                            float color@[i] = @[curtexval].r;
                            @(if $aodepthformat [result [
                                float depth@[i] = @[curdepthval].r;
                            ]] [result [
                                float depth@[i] = dot(@[curdepthval].rgb, gdepthunpackparams);
                            ]])
                        ]
                    ] [
                        result [
                            float color@[i] = @[curtexval].r;
                            @(gdepthunpack [depth@[i]] $curdepthval)
                        ]
                    ])
                    depth@[i] -= depth;
                    float weight@[i] = exp2(@(-f 0 (* $curtap $curtap))*bilateralparams.x - depth@[i]*depth@[i]*bilateralparams.y); 
                    weights += weight@[i];
                    color += weight@[i] * color@[i];
                ]
            ])
            @(if (&& (=s $filterdir "x") $packed) [
                if $aodepthformat [result [
                    fragcolor.rg = vec2(color / weights, depth);
                ]] [result [
                    @(if $upscaled [gpackdepth packdepth depth] [result [
                        #define packdepth vals.rgb
                    ]])
                    fragcolor = vec4(packdepth, color / weights);
                ]]
            ] [result [
                fragcolor = vec4(color / weights, 0.0, 0.0, 1.0);
            ]])
        }
    ]
]

bilateralshader = [
    bilateralvariantshader (format "bilateralx%1%2" $arg1 $arg2) $arg1 $arg2 $arg3 x
    bilateralvariantshader (format "bilateraly%1%2" $arg1 $arg2) $arg1 $arg2 $arg3 y
]

////////////////////////////////////////////////
//
// separable blur with up to 7 taps
//
////////////////////////////////////////////////

blurshader = [
    shader 0 $arg1 [
        attribute vec4 vvertex;
        attribute vec2 vtexcoord0;
        uniform float offsets[8];
        varying vec2 texcoord0, texcoord1, texcoord2;
        @(loopconcat i (min (- $arg2 1) 2) [result [
            varying vec2 texcoord@(+ (* $i 2) 3), texcoord@(+ (* $i 2) 4);
        ]])
        void main(void)
        {
            gl_Position = vvertex;
            texcoord0 = vtexcoord0; 
            vec2 tc1 = vtexcoord0.xy, tc2 = vtexcoord0; 
            tc1.@arg3 += offsets[1];
            tc2.@arg3 -= offsets[1];
            texcoord1 = tc1;
            texcoord2 = tc2;
            @(loopconcat i (min (- $arg2 1) 2) [result [
                tc1.@arg3 = vtexcoord0.@arg3 + offsets[@@(+ $i 2)];
                tc2.@arg3 = vtexcoord0.@arg3 - offsets[@@(+ $i 2)];
                texcoord@(+ (* $i 2) 3) = tc1;
                texcoord@(+ (* $i 2) 4) = tc2;
            ]])
        } 
    ] [
        uniform float weights[8];
        uniform float offsets[8];
        uniform sampler@[arg4] tex0;
        varying vec2 texcoord0, texcoord1, texcoord2;
        @(loopconcat i (min (- $arg2 1) 2) [result [
            varying vec2 texcoord@(+ (* $i 2) 3), texcoord@(+ (* $i 2) 4);
        ]])
        fragdata(0, fragcolor, vec4)
        void main(void)
        {
            #define texval(coords) texture@[arg4](tex0, (coords))
            vec4 val = texval(texcoord0) * weights[0];
            @(loopconcat i $arg2 [
                if (< $i 3) [result [
                    val += weights[@@(+ $i 1)] * (texval(texcoord@(+ (* $i 2) 1)) + texval(texcoord@(+ (* $i 2) 2)));
                ]] [result [
                    val += weights[@@(+ $i 1)] * 
                    @(if (=s $arg3 "x") [result [
                        (texval(vec2(texcoord0.x + offsets[@@(+ $i 1)], texcoord0.y)) + texval(vec2(texcoord0.x - offsets[@@(+ $i 1)], texcoord0.y)));
                    ]] [result [
                        (texval(vec2(texcoord0.x, texcoord0.y + offsets[@@(+ $i 1)])) + texval(vec2(texcoord0.x, texcoord0.y - offsets[@@(+ $i 1)])));
                    ]])
                ]]
            ])
            fragcolor = val;
        }
    ]
]

loop+ i 1 7 [
    blurshader (format "blurx%1" $i) $i x 2D
    blurshader (format "blury%1" $i) $i y 2D
    if (> $i 1) [
        altshader (format "blurx%1" $i) (format "blurx%1" $i)
        altshader (format "blury%1" $i) (format "blury%1" $i)
    ]
    blurshader (format "blurx%1rect" $i) $i x 2DRect
    blurshader (format "blury%1rect" $i) $i y 2DRect
    if (> $i 1) [
        altshader (format "blurx%1rect" $i) (format "blurx%1rect" $i)
        altshader (format "blury%1rect" $i) (format "blury%1rect" $i)
    ]
]

////////////////////////////////////////////////
//
// full screen shaders: 
//
////////////////////////////////////////////////

fsvs = [result [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    @arg2
    void main(void)
    {
        gl_Position = vvertex;   // woohoo, no mvp :) 
        texcoord0 = vtexcoord0; 
        @arg1
    }
]]

fsps = [result [
    uniform sampler2DRect tex0; 
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    @arg2
    void main(void)
    {
        vec4 color = texture2DRect(tex0, texcoord0);
        @arg1
    }
]]

fsvs4 = [
    fsvs [ 
        texcoord1 = vtexcoord0 + vec2(-1.5, -1.5);
        texcoord2 = vtexcoord0 + vec2( 1.5, -1.5);
        texcoord3 = vtexcoord0 + vec2(-1.5,  1.5);
        texcoord4 = vtexcoord0 + vec2( 1.5,  1.5);
        @arg1
    ] [
        varying vec2 texcoord1, texcoord2, texcoord3, texcoord4;
    ]
]

fsps4 = [
    fsps [
        vec4 s00 = texture2DRect(tex0, texcoord1);
        vec4 s02 = texture2DRect(tex0, texcoord2);
        vec4 s20 = texture2DRect(tex0, texcoord3);
        vec4 s22 = texture2DRect(tex0, texcoord4);
        @arg1
    ] [
        varying vec2 texcoord1, texcoord2, texcoord3, texcoord4;
    ]
]

// some simple ones that just do an effect on the RGB value...

lazyshader 0 "invert" (fsvs) (fsps [fragcolor = 1.0 - color;])
lazyshader 0 "gbr"    (fsvs) (fsps [fragcolor = color.yzxw;])
lazyshader 0 "bw"     (fsvs) (fsps [fragcolor = vec4(dot(color.xyz, vec3(0.333)));])

// sobel

lazyshader 0 "sobel" (fsvs4) (fsps4 [
    vec4 t = s00 + s20 - s02 - s22;
    vec4 u = s00 + s02 - s20 - s22;
    fragcolor = color + t*t + u*u;
])

// rotoscope

lazyshader 0 "rotoscope" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    uniform vec4 params;
    varying vec2 t11, t00, t12, t01, t20, t02, t21, t10, t22;
    void main(void)
    {
        gl_Position = vvertex;
        t11 = vtexcoord0;
        t00 = vec2(-1.0, -1.0)*params.x + vtexcoord0;
        t12 = vec2( 0.0,  1.0)*params.x + vtexcoord0;
        t01 = vec2(-1.0,  0.0)*params.x + vtexcoord0;
        t20 = vec2( 1.0, -1.0)*params.x + vtexcoord0;
        t02 = vec2(-1.0,  1.0)*params.x + vtexcoord0;
        t21 = vec2( 1.0,  0.0)*params.x + vtexcoord0;
        t10 = vec2( 0.0, -1.0)*params.x + vtexcoord0;
        t22 = vec2( 1.0,  1.0)*params.x + vtexcoord0;
    }
] [
    uniform sampler2DRect tex0; 
    varying vec2 t11, t00, t12, t01, t20, t02, t21, t10, t22;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec4 c00 = texture2DRect(tex0, t00);
        vec4 c01 = texture2DRect(tex0, t01);
        vec4 c02 = texture2DRect(tex0, t02);
        vec4 c10 = texture2DRect(tex0, t10);
        vec4 c11 = texture2DRect(tex0, t11);
        vec4 c12 = texture2DRect(tex0, t12);
        vec4 c20 = texture2DRect(tex0, t20);
        vec4 c21 = texture2DRect(tex0, t21);
        vec4 c22 = texture2DRect(tex0, t22);

        vec4 diag1 = c00 - c22;
        vec4 diag2 = c02 - c20;
        vec4 xedge = (c01 - c21)*2.0 + diag1 + diag2;
        vec4 yedge = (c10 - c12)*2.0 + diag1 - diag2;
        xedge *= xedge;
        yedge *= yedge;

        vec4 xyedge = xedge + yedge;
        float sobel = step(max(xyedge.x, max(xyedge.y, xyedge.z)), 0.1);

        float hue = dot(c11.xyz, vec3(1.0));
        c11 /= hue;
        vec3 cc = step(vec3(0.2, 0.8, 1.5), vec3(hue));
        c11 *= dot(cc, vec3(0.5, 0.5, 1.5)); 
        
        fragcolor = c11 * max(cc.z, sobel);
        
    }
]

blur3shader = [
    lazyshader 0 $arg1 [ 
        attribute vec4 vvertex;
        attribute vec2 vtexcoord0;
        varying vec2 texcoord0, texcoord1;
        void main(void)
        {
            gl_Position = vvertex;
            texcoord0 = vtexcoord0 + vec2(@(if $arg2 -0.5 0.0), @(if $arg3 -0.5 0.0));
            texcoord1 = vtexcoord0 + vec2(@(if $arg2  0.5 0.0), @(if $arg3  0.5 0.0));
        }
    ] [
        uniform sampler2DRect tex0; 
        varying vec2 texcoord0, texcoord1;
        fragdata(0, fragcolor, vec4)
        void main(void)
        {
            fragcolor = 0.5*(texture2DRect(tex0, texcoord0) + texture2DRect(tex0, texcoord1));
        }
    ]
]
blur3shader hblur3 1 0
blur3shader vblur3 0 1

blur5shader = [
    lazyshader 0 $arg1 [ 
        attribute vec4 vvertex;
        attribute vec2 vtexcoord0;
        varying vec2 texcoord0, texcoord1, texcoord2;
        void main(void)
        {
            gl_Position = vvertex;
            texcoord0 = vtexcoord0;
            texcoord1 = vtexcoord0 + vec2(@(if $arg2 -1.333 0.0), @(if $arg3 -1.333 0.0));
            texcoord2 = vtexcoord0 + vec2(@(if $arg2  1.333 0.0), @(if $arg3  1.333 0.0));
        }
    ] [
        uniform sampler2DRect tex0; 
        varying vec2 texcoord0, texcoord1, texcoord2;
        fragdata(0, fragcolor, vec4)
        void main(void)
        {
            fragcolor = 0.4*texture2DRect(tex0, texcoord0) + 0.3*(texture2DRect(tex0, texcoord1) + texture2DRect(tex0, texcoord2));
        }
    ]
]
blur5shader hblur5 1 0
blur5shader vblur5 0 1

rotoscope = [
    clearpostfx
    if (>= $numargs 1) [addpostfx rotoscope 0 0 0 $arg1]
    if (>= $numargs 2) [
        if (= $arg2 1) [addpostfx hblur3; addpostfx vblur3]
        if (= $arg2 2) [addpostfx hblur5; addpostfx vblur5]
    ]
]

////////////////////////////////////////////////
//
// miscellaneous effect shaders: 
//
////////////////////////////////////////////////

// wobbles the vertices of an explosion sphere
// and generates all texcoords 
// and blends the edge color
// and modulates the texture
explosionshader = [
    shader 0 $arg1 [
        #pragma CUBE2_fog
        attribute vec4 vvertex, vcolor;
        uniform mat4 explosionmatrix;
        uniform vec3 center;
        uniform vec4 animstate;
        uniform float side;
        @(? (>= (strstr $arg1 "3d") 0) [
            attribute vec2 vtexcoord0;
            varying vec2 texcoord2;
            uniform vec4 texgenS, texgenT;
        ])
        @(? (>= (strstr $arg1 "soft") 0) [
            uniform vec2 lineardepthscale;
            varying float lineardepth;
        ]) 
        varying vec4 color;
        varying vec2 texcoord0, texcoord1;
        void main(void)
        {
            vec4 wobble = vec4(vvertex.xyz*(1.0 + 0.5*abs(fract(dot(vvertex.xyz, center) + animstate.w*2.0) - 0.5)), vvertex.w);
            wobble.z *= side;
            gl_Position = explosionmatrix * wobble;
            @(? (>= (strstr $arg1 "soft") 0) [
                lineardepth = dot(lineardepthscale, gl_Position.zw);
            ])

            color = vcolor;
        
            @(? (>= (strstr $arg1 "3d") 0) [
                texcoord0 = vtexcoord0; 
                vec2 texgen = vec2(dot(texgenS, vvertex), dot(texgenT, vvertex)); 
                texcoord1 = texgen;
                texcoord2 = texgen - animstate.w*0.5;
            ] [
                //blow up the tex coords
                float dtc = 1.768 - animstate.x*1.414; // -2, 2.5; -> -2*sqrt(0.5), 2.5*sqrt(0.5);
                dtc *= dtc;
                texcoord0 = animstate.w*0.4 + dtc*vvertex.xy;
                texcoord1 = vvertex.xy*0.5 + 0.5; //using wobble makes it look too spherical at a distance
            ])
        } 
    ] [ 
        @(? (>= (strstr $arg1 "3d") 0) [
            varying vec2 texcoord2;
        ])
        @(if (>= (strstr $arg1 "soft") 0) [result [
            @(gfetchdefs tex2)
            uniform vec3 softparams;
            varying float lineardepth;
        ]])
        varying vec4 color;
        varying vec2 texcoord0, texcoord1;
        uniform sampler2D tex0, tex1;
        fragdata(0, fragcolor, vec4)
        void main(void)
        {
            vec2 dtc = texcoord0 + texture2D(tex0, @(? (>= (strstr $arg1 "3d") 0) "texcoord2" "texcoord1")).xy*0.1; // use color texture as noise to distort texcoords
            vec4 diffuse = texture2D(tex0, dtc);
            float blend = texture2D(tex1, texcoord1).r; // get blend factors from modulation texture 
            diffuse *= blend*4.0; // dup alpha into RGB channels + intensify and over saturate
            diffuse.b += 0.5 - blend*0.5; // blue tint 

            @(if (>= (strstr $arg1 "soft") 0) [result [
                fragcolor.rgb = diffuse.rgb * color.rgb;

                @(gdepthunpack depth [gfetch(tex2, gl_FragCoord.xy)])
                fragcolor.a = diffuse.a * max(clamp((depth - lineardepth)*softparams.x - softparams.y, 0.0, 1.0) * color.a, softparams.z);
            ]] [result [
                fragcolor = diffuse * color;
            ]])
        }
    ]
]

explosionshader "explosion2d"
explosionshader "explosion2dsoft"
explosionshader "explosion3d"
explosionshader "explosion3dsoft"

shader 0 "particlenotexture" [
    #pragma CUBE2_fog
    attribute vec4 vvertex, vcolor;
    uniform mat4 camprojmatrix;
    uniform vec4 colorscale;
    varying vec4 color;
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        color = vcolor * colorscale;
    } 
] [
    varying vec4 color;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = color;
    }
]

shader 0 "particletext" [
    #pragma CUBE2_fog
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 camprojmatrix;
    uniform float ldrscale;
    varying vec4 color;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        texcoord0 = vtexcoord0;
        color = vec4(vcolor.rgb * ldrscale, vcolor.a);
    }
] [
    uniform vec4 textparams;
    uniform sampler2D tex0;
    varying vec4 color;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        float dist = texture2D(tex0, texcoord0).r;
        float border = smoothstep(textparams.x, textparams.y, dist);
        float outline = smoothstep(textparams.z, textparams.w, dist);
        fragcolor = vec4(color.rgb * outline, color.a * border);
    }
]

particleshader = [
    shader 0 $arg1 [
        #pragma CUBE2_fog
        attribute vec4 vvertex, vcolor;
        attribute vec2 vtexcoord0;
        uniform mat4 camprojmatrix;
        uniform vec4 colorscale;
        varying vec4 color;
        varying vec2 texcoord0;
        @(? (>= (strstr $arg1 "soft") 0) [
            uniform vec2 lineardepthscale;
            varying float lineardepth;
            varying vec2 surface;
        ])
        void main(void)
        {
            gl_Position = camprojmatrix * vvertex;
            texcoord0 = vtexcoord0; 
            color = vcolor * colorscale; 

            @(? (>= (strstr $arg1 "soft") 0) [
                lineardepth = dot(lineardepthscale, gl_Position.zw);
                surface = vtexcoord0.xy*2.82842712474619 - 1.4142135623731;
            ])
        }
    ] [
        @(if (>= (strstr $arg1 "soft") 0) [result [
            @(gfetchdefs tex2)
            uniform vec3 softparams;
            varying float lineardepth;
            varying vec2 surface;
        ]])
        uniform sampler2D tex0;
        varying vec4 color;
        varying vec2 texcoord0;
        fragdata(0, fragcolor, vec4)
        void main(void)
        {
            vec4 diffuse = texture2D(tex0, texcoord0);
            #pragma CUBE2_swizzle diffuse
            
            @(if (>= (strstr $arg1 "soft") 0) [result [
                @(gdepthunpack depth [gfetch(tex2, gl_FragCoord.xy)])
                diffuse.a *= clamp((depth - lineardepth)*softparams.x - softparams.y - dot(surface, surface), 0.0, 1.0);
            ]])

            fragcolor = diffuse * color;
        }
    ]     
]

particleshader "particle"
particleshader "particlesoft"

shader 0 "blendbrush" [
    attribute vec4 vvertex, vcolor;
    uniform mat4 camprojmatrix;
    uniform vec4 texgenS, texgenT;
    uniform float ldrscale;
    varying vec4 color;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        color = vec4(ldrscale * vcolor.rgb, vcolor.a);
        texcoord0 = vec2(dot(texgenS, vvertex), dot(texgenT, vvertex));
    }
] [
    uniform sampler2D tex0;
    varying vec4 color;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = texture2D(tex0, texcoord0).r * color;
    }
]

shader 0 "fogoverlay" [
    attribute vec4 vvertex, vcolor;
    varying vec4 color;
    void main(void)
    {
        gl_Position = vvertex;
        color = vcolor;
    }
] [
    varying vec4 color;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = color;
    }
]

lazyshader 0 "moviergb" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
    }
] [
    uniform sampler2DRect tex0;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = texture2DRect(tex0, texcoord0);
    }
]

lazyshader 0 "movieyuv" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
    }
] [
    uniform sampler2DRect tex0;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec3 color = texture2DRect(tex0, texcoord0).rgb;
        fragcolor = vec4(dot(color, vec3(0.439216, -0.367788, -0.071427)) + 0.501961,
                         dot(color, vec3(-0.148224, -0.290992, 0.439216)) + 0.501961,
                         dot(color, vec3(0.256788, 0.504125, 0.097905)) + 0.062745,
                         0.0);
    }
]

lazyshader 0 "moviey" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0 + vec2(0.5, 0.0);
    }
] [
    uniform sampler2DRect tex0;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec3 color1 = texture2DRectOffset(tex0, texcoord0, ivec2( -2, 0)).rgb;
        vec3 color2 = texture2DRectOffset(tex0, texcoord0, ivec2( -1, 0)).rgb;
        vec3 color3 = texture2DRect(tex0, texcoord0).rgb;
        vec3 color4 = texture2DRectOffset(tex0, texcoord0, ivec2( 1, 0)).rgb;
        fragcolor = vec4(dot(color3, vec3(0.256788, 0.504125, 0.097905)) + 0.062745,
                         dot(color2, vec3(0.256788, 0.504125, 0.097905)) + 0.062745,
                         dot(color1, vec3(0.256788, 0.504125, 0.097905)) + 0.062745,
                         dot(color4, vec3(0.256788, 0.504125, 0.097905)) + 0.062745);
    }
]

lazyshader 0 "movieu" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0;
    }
] [
    uniform sampler2DRect tex0;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec3 color1 = texture2DRectOffset(tex0, texcoord0, ivec2(-3, 0)).rgb;
        vec3 color2 = texture2DRectOffset(tex0, texcoord0, ivec2(-1, 0)).rgb;
        vec3 color3 = texture2DRectOffset(tex0, texcoord0, ivec2( 1, 0)).rgb;
        vec3 color4 = texture2DRectOffset(tex0, texcoord0, ivec2( 3, 0)).rgb;
        fragcolor = vec4(dot(color3, vec3(-0.148224, -0.290992, 0.43921)) + 0.501961,
                         dot(color2, vec3(-0.148224, -0.290992, 0.43921)) + 0.501961,
                         dot(color1, vec3(-0.148224, -0.290992, 0.43921)) + 0.501961,
                         dot(color4, vec3(-0.148224, -0.290992, 0.43921)) + 0.501961);
    }
]

lazyshader 0 "moviev" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0;
    }
] [
    uniform sampler2DRect tex0;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec3 color1 = texture2DRectOffset(tex0, texcoord0, ivec2(-3, 0)).rgb;
        vec3 color2 = texture2DRectOffset(tex0, texcoord0, ivec2(-1, 0)).rgb;
        vec3 color3 = texture2DRectOffset(tex0, texcoord0, ivec2( 1, 0)).rgb;
        vec3 color4 = texture2DRectOffset(tex0, texcoord0, ivec2( 3, 0)).rgb;
        fragcolor = vec4(dot(color3, vec3(0.439216, -0.367788, -0.071427)) + 0.501961,
                         dot(color2, vec3(0.439216, -0.367788, -0.071427)) + 0.501961,
                         dot(color1, vec3(0.439216, -0.367788, -0.071427)) + 0.501961,
                         dot(color4, vec3(0.439216, -0.367788, -0.071427)) + 0.501961);
    }
]

///////////////////////////////////////////////////
//
// reflective/refractive water shaders:
//
///////////////////////////////////////////////////

shader 0 "refractmask" [
    attribute vec4 vvertex;
    uniform mat4 camprojmatrix;
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
    }
] [
    @(gfetchdefs tex0)
    uniform vec3 gdepthpackparams;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        @(if (= $gdepthformat 1) [result [
            vec3 packdepth = gfetch(tex0, gl_FragCoord.xy).rgb;
            float depth = dot(packdepth, gdepthunpackparams);
        ]] [result [
            @(gdepthunpack depth [gfetch(tex0, gl_FragCoord.xy)]) 
            @(gpackdepth packdepth depth)
        ]])
        fragcolor = vec4(packdepth, 0.0);
    }
]

lazyshader 0 "waterminimap" [
    attribute vec4 vvertex;
    uniform mat4 camprojmatrix;
    @(ginterpvert)
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        @(gdepthpackvert)
    }
] [
    uniform vec3 watercolor;
    @(ginterpfrag)

    void main(void)
    {
        gcolor = vec4(0.0, 0.0, 0.0, 0.0);
        gnormal = vec4(0.5, 0.5, 1.0, 0.0);
        gglow = vec4(watercolor, 1.0);
        @(gdepthpackfrag)
    }
]

watershader = [
  lazyshader 0 $arg1 [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    uniform mat4 camprojmatrix;
    uniform vec3 camera;
    varying vec2 texcoord0, texcoord1;
    varying vec3 surface;
    @(? (>= (strstr $arg1 "reflect") 0) [
        uniform mat4 raymatrix;
        varying vec3 esurface;
    ])
    @(ginterpvert 1)
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        surface = vvertex.xyz;
        @(? (>= (strstr $arg1 "reflect") 0) [
            esurface = (raymatrix * vvertex).xyz;
        ])
        texcoord0 = vtexcoord0 * 0.20;
        texcoord1 = vtexcoord0 * 0.06;
        @(gdepthpackvert 1)
    }
  ] [
    @(gfetchdefs [tex7 tex8 tex9])
    uniform float millis;
    uniform vec3 camera;
    uniform mat4 linearworldmatrix;
    varying vec2 texcoord0, texcoord1;
    varying vec3 surface;
    uniform sampler2D tex0, tex1;
    uniform vec4 viewsize;
    uniform vec3 watercolor, waterdeepcolor, waterdeepfade;
    uniform float waterfog, waterspec;
    uniform vec4 waterreflect, waterrefract;
    uniform float refractdepth;
    @(? (>= (strstr $arg1 "caustics") 0) [
        uniform vec3 causticsS, causticsT;
        uniform vec3 causticsblend;
        uniform sampler2D tex2, tex3;
    ])
    @(? (>= (strstr $arg1 "env") 0) [
        uniform samplerCube tex4;
    ])
    @(? (>= (strstr $arg1 "reflect") 0) [
        uniform mat4 raymatrix;
        varying vec3 esurface;
    ])
    @(ginterpfrag 1)

    void main(void)
    {
        vec3 camdir = camera - surface, camvec = normalize(camdir);
        vec3 bump  = texture2D(tex1, texcoord0 + millis*vec2( 0.25,  0.75)*0.0750).rgb;
        vec3 bump2 = texture2D(tex1, texcoord0 + millis*vec2(-0.75, -0.25)*0.0950).rgb;
        vec3 bump3 = texture2D(tex1, texcoord1 + millis*vec2(-0.50,  0.50)*0.0505).rgb;
        vec3 bump4 = texture2D(tex1, texcoord1 + millis*vec2( 0.25, -0.75)*0.0525).rgb;
        bump = normalize(bump + bump2 + bump3 + bump4 - 2.0);
        vec2 rtc = bump.xy * waterrefract.w;

        float rmask = clamp(refractdepth*(lineardepth - dot(gfetch(tex7, gl_FragCoord.xy + rtc).rgb, gdepthunpackparams)), 0.0, 1.0);
        rtc = gl_FragCoord.xy + rtc*rmask;
        vec3 rcolor = gfetch(tex8, rtc).rgb * waterrefract.xyz;
        float rdepth = dot(gfetch(tex7, rtc).rgb, gdepthunpackparams);
        vec3 rpos = (linearworldmatrix * vec4(rdepth*rtc, rdepth, 1.0)).xyz;

        @(if (>= (strstr $arg1 "under") 0) [result [
            float above = rpos.z - surface.z; 
            float alpha = clamp(above, 0.0, 1.0);
        ]] [result [
            vec3 rdir = rpos.xyz - camera;
            float raydepth = length(rdir)*(1.0 + camdir.z/rdir.z);
            float deep = surface.z - rpos.z;
            float alpha = clamp(deep*0.5, 0.0, 1.0);

            @(? (>= (strstr $arg1 "caustics") 0) [
                vec2 ctc = vec2(dot(causticsS, rpos.xyz), dot(causticsT, rpos.xyz));
                float caustics = causticsblend.x*texture2D(tex2, ctc).r + causticsblend.y*texture2D(tex3, ctc).r + causticsblend.z;
                rcolor *= caustics;
            ])

            rcolor = mix(watercolor, rcolor, clamp(exp2(waterfog * raydepth), 0.0, 1.0));
            rcolor = mix(waterdeepcolor, rcolor, clamp(exp2(deep * waterdeepfade), 0.0, 1.0));
        ]])

        vec3 reflectdir = -reflect(camvec, bump);
        reflectdir.z = abs(reflectdir.z);
        @(if (>= (strstr $arg1 "reflect") 0) [result [
            reflectdir.z += 0.125;
            vec3 edir = (raymatrix * vec4(waterreflect.w*reflectdir, 0.0)).xyz;
            vec3 epos = esurface + edir;
            @(loopconcat i 4 [result [
                @(gdepthunpack [edepth@[i]] [gfetchproj(tex9, epos)] [
                    if(edepth@[i] < epos.z || edepth@[i] > esurface.z) epos += edir;
                ] [
                    edepth@[i] = edepth@[i]*gdepthscale.y + gdepthscale.z;
                    if(gdepthscale.x < epos.z*edepth@[i] || gdepthscale.x > esurface.z*edepth@[i]) epos += edir;
                ])
            ]])
            vec2 etc = epos.xy/epos.z;
            vec3 reflect = gfetchclamp(tex8, etc).rgb * waterreflect.xyz;
            float edgefade = clamp(4.0*(0.5 - max(abs(etc.x*viewsize.z - 0.5)*0.75 + 0.25/4.0, abs(etc.y*viewsize.w - 0.5))), 0.0, 1.0);
            float fresnel = 0.25 + 0.75*pow(clamp(1.0 - dot(camvec, bump), 0.0, 1.0), 4.0);
            rcolor = mix(rcolor, reflect, fresnel*edgefade);
        ]] [if (>= (strstr $arg1 "env") 0) [result [
            vec3 reflect = textureCube(tex4, reflectdir).rgb*0.5;
            float fresnel = 0.5*pow(clamp(1.0 - dot(camvec, bump), 0.0, 1.0), 4.0);
            rcolor = mix(rcolor, reflect, fresnel);
        ]]])

        gcolor = vec4(0.0, 0.0, 0.0, waterspec*alpha);
        gnormal = vec4(bump*0.5+0.5, 0.0);
        gglow = vec4(rcolor*alpha, alpha);
        @(gdepthpackfrag)
    }
  ]  
]

watershader "water"
watershader "watercaustics"
watershader "waterenv"
watershader "waterenvcaustics"
watershader "waterreflect"
watershader "waterreflectcaustics"
watershader "underwater"

causticshader = [
    lazyshader 0 $arg1 [
        attribute vec4 vvertex;
        void main(void)
        {
            gl_Position = vvertex;
        }
    ] [
        @(gfetchdefs tex9)
        uniform mat4 causticsmatrix;
        uniform vec3 causticsblend;
        uniform sampler2D tex0, tex1;
        uniform vec4 waterdeepfade;
        fragdata(0, fragcolor, vec4)
        void main(void)
        {
            @(gdepthunpack depth [gfetch(tex9, gl_FragCoord.xy)] [
                vec3 ctc = (causticsmatrix * vec4(depth*gl_FragCoord.xy, depth, 1.0)).xyz;
            ] [
                vec4 ctc = causticsmatrix * vec4(gl_FragCoord.xy, depth, 1.0);
                ctc.xyz /= ctc.w;
            ])
            float caustics = causticsblend.x*texture2D(tex0, ctc.xy).r + causticsblend.y*texture2D(tex1, ctc.xy).r + causticsblend.z;
            caustics *= clamp(ctc.z, 0.0, 1.0) * clamp(exp2(ctc.z*waterdeepfade.w), 0.0, 1.0);
            fragcolor.rgb = vec3(0.5 + caustics);
        }
    ]
]
causticshader caustics

waterfogshader = [
    lazyshader 0 $arg1 [
        attribute vec4 vvertex;
        void main(void)
        {
            gl_Position = vvertex;
        }
    ] [
        @(gfetchdefs tex9)
        uniform vec3 camera;
        uniform mat4 worldmatrix;
        uniform vec3 fogcolor;
        uniform vec2 fogdensity;
        uniform vec3 waterdeepcolor, waterdeepfade;
        uniform float waterheight;
        fragdata(0, fragcolor, vec4)
        void main(void)
        {
            @(gdepthunpack depth [gfetch(tex9, gl_FragCoord.xy)] [
                vec3 pos = (worldmatrix * vec4(depth*gl_FragCoord.xy, depth, 1.0)).xyz;
            ] [
                vec4 pos = worldmatrix * vec4(gl_FragCoord.xy, depth, 1.0);
                pos.xyz /= pos.w;
            ])
            float fogbelow = waterheight - pos.z;
            float fogcoord = distance(camera, pos.xyz);
            float foglerp = clamp(1.0 - exp2(fogcoord*fogdensity.x)*fogdensity.y, 0.0, 1.0);
            foglerp *= clamp(2.0*fogbelow + 0.5, 0.0, 1.0);
            vec3 color = mix(waterdeepcolor, fogcolor, clamp(exp2(fogbelow*waterdeepfade), 0.0, 1.0));
            fragcolor.rgb = color;
            fragcolor.a = foglerp;
        }
    ]
]
waterfogshader waterfog

lazyshader 0 "lava" [
    attribute vec4 vvertex;
    attribute vec3 vnormal;
    attribute vec2 vtexcoord0;
    uniform mat4 camprojmatrix;
    varying mat3 world;
    varying vec2 texcoord0;
    @(ginterpvert)
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        texcoord0 = vtexcoord0; 
        vec3 tangent = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), abs(vnormal.x));
        vec3 bitangent = mix(vec3(0.0, 0.0, -1.0), vec3(0.0, 1.0, 0.0), abs(vnormal.z));
        world = mat3(tangent, bitangent, vnormal);
        @(gdepthpackvert)
    }
] [
    uniform sampler2D tex0, tex1;
    uniform float lavaglow, lavaspec;
    varying mat3 world;
    varying vec2 texcoord0;
    @(ginterpfrag)

    void main(void)
    {
        vec3 diffuse = texture2D(tex0, texcoord0).rgb;
        vec3 bump = texture2D(tex1, texcoord0).rgb*2.0-1.0;
        vec3 bumpw = world * bump;
        gcolor = vec4(diffuse, lavaspec);
        gnormal = vec4(bumpw*0.5+0.5, 0.0);
        gglow = vec4(diffuse*lavaglow, 1.0);
        @(gdepthpackfrag)
    }
]

lazyshader 0 "waterfallenv" [
    attribute vec4 vvertex;
    attribute vec3 vnormal;
    attribute vec2 vtexcoord0;
    uniform mat4 camprojmatrix;
    uniform vec4 camera;
    varying vec3 camdir;
    varying mat3 world;
    varying vec2 texcoord0;
    @(ginterpvert 1)
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        texcoord0 = vtexcoord0; 
        camdir = camera.xyz - vvertex.xyz;
        vec3 tangent = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), abs(vnormal.x));
        vec3 bitangent = mix(vec3(0.0, 0.0, -1.0), vec3(0.0, 1.0, 0.0), abs(vnormal.z));
        world = mat3(tangent, bitangent, vnormal);
        @(gdepthpackvert 1)
    }
] [
    @(gfetchdefs [tex7 tex8])
    uniform samplerCube tex3;
    uniform sampler2D tex0, tex1;
    uniform vec3 waterfallcolor;
    uniform float waterfallspec;
    uniform vec4 waterfallrefract;
    uniform float refractdepth;
    varying vec3 camdir;
    varying mat3 world;
    varying vec2 texcoord0;
    @(ginterpfrag 1)

    void main(void)
    {
        vec3 camvec = normalize(camdir);
        vec3 diffuse = texture2D(tex0, texcoord0).rgb;
        vec3 bump = texture2D(tex1, texcoord0).rgb*2.0 - 1.0;
        vec3 bumpw = world * bump;

        vec2 rtc = bump.xy * waterfallrefract.w;
        float rmask = clamp(refractdepth*(lineardepth - dot(gfetch(tex7, gl_FragCoord.xy + rtc).rgb, gdepthunpackparams)), 0.0, 1.0);
        rtc = gl_FragCoord.xy + rtc*rmask;
        vec3 rcolor = gfetch(tex8, rtc).rgb * waterfallrefract.xyz;

        float invfresnel = dot(camvec, bumpw);
        vec3 env = textureCube(tex3, 2.0*bumpw*invfresnel - camvec).rgb;
        env *= 0.1 + 0.4*pow(clamp(1.0 - invfresnel, 0.0, 1.0), 2.0);

        gcolor = vec4(0.0, 0.0, 0.0, waterfallspec*(1.0 - dot(diffuse, vec3(0.33))));
        gnormal = vec4(bumpw*0.5+0.5, 0.0);
        gglow = vec4(mix(rcolor, waterfallcolor, diffuse) + env, 1.0);
        @(gdepthpackfrag)
    }
]

lazyshader 0 "waterfall" [
    attribute vec4 vvertex;
    attribute vec3 vnormal;
    attribute vec2 vtexcoord0;
    uniform mat4 camprojmatrix;
    varying mat3 world;
    varying vec2 texcoord0;
    @(ginterpvert 1)
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        texcoord0 = vtexcoord0; 
        vec3 tangent = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), abs(vnormal.x));
        vec3 bitangent = mix(vec3(0.0, 0.0, -1.0), vec3(0.0, 1.0, 0.0), abs(vnormal.z));
        world = mat3(tangent, bitangent, vnormal);
        @(gdepthpackvert 1)
    }
] [ 
    @(gfetchdefs [tex7 tex8])
    uniform sampler2D tex0, tex1;
    uniform vec3 waterfallcolor;
    uniform float waterfallspec;
    uniform vec4 waterfallrefract;
    uniform float refractdepth;
    varying mat3 world;
    varying vec2 texcoord0;
    @(ginterpfrag 1)

    void main(void)
    {
        vec3 diffuse = texture2D(tex0, texcoord0).rgb;
        vec3 bump = texture2D(tex1, texcoord0).rgb*2.0 - 1.0;
        vec3 bumpw = world * bump;

        vec2 rtc = bump.xy * waterfallrefract.w;
        float rmask = clamp(refractdepth*(lineardepth - dot(gfetch(tex7, gl_FragCoord.xy + rtc).rgb, gdepthunpackparams)), 0.0, 1.0);
        rtc = gl_FragCoord.xy + rtc*rmask;
        vec3 rcolor = gfetch(tex8, rtc).rgb * waterfallrefract.xyz;

        gcolor = vec4(0.0, 0.0, 0.0, waterfallspec*(1.0 - dot(diffuse, vec3(0.33))));
        gnormal = vec4(bumpw*0.5+0.5, 0.0);
        gglow = vec4(mix(rcolor, waterfallcolor, diffuse), 1.0);
        @(gdepthpackfrag)
    }
]
altshader waterfallenv waterfall

lazyshader 0 "glassenv" [
    attribute vec4 vvertex;
    attribute vec3 vnormal;
    attribute vec2 vtexcoord0;
    uniform mat4 camprojmatrix;
    uniform vec4 camera;
    varying vec3 camdir;
    varying mat3 world;
    varying vec2 texcoord0;
    @(ginterpvert 1)
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        texcoord0 = vtexcoord0; 
        camdir = camera.xyz - vvertex.xyz;
        vec3 tangent = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), abs(vnormal.x));
        vec3 bitangent = mix(vec3(0.0, 0.0, -1.0), vec3(0.0, 1.0, 0.0), abs(vnormal.z));
        world = mat3(tangent, bitangent, vnormal);
        @(gdepthpackvert 1)
    }
] [ 
    @(gfetchdefs [tex7 tex8])
    uniform samplerCube tex0;
    uniform sampler2D tex1;
    uniform float glassspec;
    uniform vec4 glassrefract;
    uniform float refractdepth;
    varying vec3 camdir;
    varying mat3 world;
    varying vec2 texcoord0;
    @(ginterpfrag 1)

    void main(void)
    {
        vec3 camvec = normalize(camdir);
        vec3 bump = texture2D(tex1, texcoord0).rgb*2.0 - 1.0;
        vec3 bumpw = world * bump;

        vec2 rtc = bump.xy * glassrefract.w;
        float rmask = clamp(refractdepth*(lineardepth - dot(gfetch(tex7, gl_FragCoord.xy + rtc).rgb, gdepthunpackparams)), 0.0, 1.0);
        rtc = gl_FragCoord.xy + rtc*rmask;
        vec3 rcolor = gfetch(tex8, rtc).rgb;
        rcolor *= glassrefract.xyz;
      
        float invfresnel = dot(camvec, bumpw);
        vec3 env = textureCube(tex0, 2.0*bumpw*invfresnel - camvec).rgb;
        env *= 0.1 + 0.4*pow(clamp(1.0 - invfresnel, 0.0, 1.0), 2.0);
  
        gcolor = vec4(0.0, 0.0, 0.0, glassspec);
        gnormal = vec4(bumpw*0.5+0.5, 0.0);
        gglow = vec4(rcolor + env, 1.0);
        @(gdepthpackfrag)
    }
]

lazyshader 0 "glass" [
    attribute vec4 vvertex;
    attribute vec3 vnormal;
    attribute vec2 vtexcoord0;
    uniform mat4 camprojmatrix;
    varying mat3 world;
    varying vec2 texcoord0;
    @(ginterpvert 1)
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        texcoord0 = vtexcoord0; 
        vec3 tangent = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), abs(vnormal.x));
        vec3 bitangent = mix(vec3(0.0, 0.0, -1.0), vec3(0.0, 1.0, 0.0), abs(vnormal.z));
        world = mat3(tangent, bitangent, vnormal);
        @(gdepthpackvert 1)
    }
] [
    @(gfetchdefs [tex7 tex8])
    uniform sampler2D tex1;
    uniform float glassspec;
    uniform vec4 glassrefract;
    uniform float refractdepth;
    varying mat3 world;
    varying vec2 texcoord0;
    @(ginterpfrag 1)

    void main(void)
    {
        vec3 bump = texture2D(tex1, texcoord0).rgb*2.0 - 1.0;
        vec3 bumpw = world * bump;

        vec2 rtc = bump.xy * glassrefract.w;
        float rmask = clamp(refractdepth*(lineardepth - dot(gfetch(tex7, gl_FragCoord.xy + rtc).rgb, gdepthunpackparams)), 0.0, 1.0);
        rtc = gl_FragCoord.xy + rtc*rmask;
        vec3 rcolor = gfetch(tex8, rtc).rgb;
        rcolor *= glassrefract.xyz;
        
        gcolor = vec4(0.0, 0.0, 0.0, glassspec);
        gnormal = vec4(bumpw*0.5+0.5, 0.0);
        gglow = vec4(rcolor, 1.0); 
        @(gdepthpackfrag)
    }
]
altshader glassenv glass

defershader 0 "grass" [
  loop i 2 [
    variantshader 0 "grass" (? $i 0 -1) [
        attribute vec4 vvertex, vcolor;
        attribute vec2 vtexcoord0;
        uniform mat4 camprojmatrix;
        @(ginterpvert)
        varying vec2 texcoord0;
        varying vec4 colorscale;
        @(? $i [uniform vec4 blendmapparams; varying vec2 texcoord1;])
        void main(void)
        {
            gl_Position = camprojmatrix * vvertex;
            colorscale = vcolor;
            texcoord0 = vtexcoord0; 
            @(? $i [
                texcoord1 = (vvertex.xy - blendmapparams.xy)*blendmapparams.zw;
            ])
            @(gdepthpackvert)
        }
    ] [
        uniform sampler2D tex0;
        uniform float grasstest;
        @(ginterpfrag)
        varying vec2 texcoord0;
        varying vec4 colorscale;
        @(? $i [uniform sampler2D tex1; varying vec2 texcoord1;])
        void main(void)
        {
            vec4 color = texture2D(tex0, texcoord0) * colorscale;
            @(? $i [
                color.a *= texture2D(tex1, texcoord1).r;
            ])
            if(color.a <= grasstest)
                discard;
            gcolor = vec4(color.rgb, 0.0);
            gnormal = vec4(0.5, 0.5, 1.0, 0.0); 
            gglow = vec4(0.0, 0.0, 0.0, 1.0);
            @(gdepthpackfrag)
        }
    ]
  ]
]

shader 0 "overbrightdecal" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 camprojmatrix;
    varying vec4 color;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        color = vcolor;
        texcoord0 = vtexcoord0; 
    }
] [
    uniform sampler2D tex0;
    varying vec4 color;
    varying vec2 texcoord0;
    fragdata(0, gcolor, vec4)
    fragdata(1, gglow, vec4)
    void main(void)
    {
        vec4 diffuse = texture2D(tex0, texcoord0);
        #pragma CUBE2_swizzle diffuse
        diffuse.rgb = mix(color.rgb, diffuse.rgb, color.a);
        gcolor.rgb = diffuse.rgb;
        gcolor.a = 0.5;
        gglow.rgb = diffuse.rgb;
        gglow.a = 0.5;
    }
]

shader 0 "decal" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 camprojmatrix;
    uniform vec4 colorscale;
    varying vec4 color;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        texcoord0 = vtexcoord0;
        color = vcolor * colorscale;
    }
] [
    uniform sampler2D tex0;
    varying vec4 color;
    varying vec2 texcoord0;
    fragdata(0, gcolor, vec4)
    fragdata(1, gglow, vec4)
    void main(void)
    {
        vec4 diffuse = texture2D(tex0, texcoord0);
        #pragma CUBE2_swizzle diffuse
        diffuse *= color;
        gcolor = diffuse;
        gglow.rgb = vec3(0.0);
        gglow.a = diffuse.a;
    }
]

shader 0 "skybox" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 skymatrix;
    uniform float ldrscale;
    varying vec4 colorscale;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = skymatrix * vvertex;
        texcoord0 = vtexcoord0; 
        colorscale = vec4(ldrscale * vcolor.rgb, vcolor.a);
    }
] [
    uniform sampler2D tex0;
    varying vec4 colorscale;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec4 color = texture2D(tex0, texcoord0);
        #pragma CUBE2_swizzle color
        fragcolor = colorscale * color;
    }
]

shader 0 "skyboxoverbright" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 skymatrix;
    uniform float ldrscale;
    varying vec4 colorscale;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = skymatrix * vvertex;
        texcoord0 = vtexcoord0; 
        colorscale = vec4(ldrscale * vcolor.rgb, vcolor.a);
    }
] [
    uniform sampler2D tex0;
    uniform vec3 overbrightparams;
    uniform float ldrscale;
    varying vec4 colorscale;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec4 color = texture2D(tex0, texcoord0);
        #pragma CUBE2_swizzle color
        float lum = dot(vec3(@lumweights), color.rgb);
        float overbright = mix(overbrightparams.x, overbrightparams.y, clamp(lum - overbrightparams.z, 0.0, 1.0));
        color.rgb *= overbright;
        fragcolor = colorscale * color;
    }
]

shader 0 "atmosphere" [
    attribute vec4 vvertex;
    uniform mat4 sunmatrix;
    varying vec3 camvec;
    void main(void)
    {
        gl_Position = vvertex;

        vec4 p = sunmatrix * vvertex;
        camvec = p.xyz / p.w;
    }
] [
    // adapted from http://blog.cloudparty.com/2013/09/25/stunning-procedural-skies-in-webgl-part-2/
    uniform vec3 sunlight;
    uniform vec3 sundir;
    uniform vec3 sundiskparams;
    uniform vec3 atmoradius;
    uniform float gm;
    uniform vec3 betar, betam, betarm;
    uniform vec2 hdrgamma;
    uniform float atmoalpha;
    varying vec3 camvec;
    fragdata(0, fragcolor, vec4)

    vec3 calcextinction(float dist) 
    {
        return exp2(-dist * betarm);
    }
 
    vec3 calcscatter(float costheta) 
    {
        float rphase = 1.0 + costheta*costheta;
        float mphase = pow(1.0 + gm*(gm - 2.0*costheta), -1.5);
        return betar*rphase + betam*mphase;
    }
 
    float baseopticaldepth(vec3 ray) 
    {
        float a = atmoradius.x * max(ray.z, min(sundir.z, 0.0));
        return sqrt(a*a + atmoradius.z) - a;
    }
 
    float opticaldepth(vec3 pos, vec3 ray) 
    {
        pos.z = max(pos.z, 0.0) + atmoradius.x;
        float a = dot(pos, ray);
        return sqrt(a*a + atmoradius.y - dot(pos, pos)) - a;
    }

    void main(void)
    {
        vec3 camdir = normalize(camvec);
        float costheta = dot(camdir, sundir);
 
        // optical depth along view ray
        float raydist = baseopticaldepth(camdir);
 
        // extinction of light along view ray
        vec3 extinction = calcextinction(raydist);
 
        // optical depth for incoming light hitting the view ray
        float lightraydist = opticaldepth(camdir * (raydist * max(0.15 + 0.75 * sundir.z, 0.0)), sundir);
 
        // cast a ray towards the sun and calculate the incoming extincted light
        vec3 incominglight = calcextinction(lightraydist);
 
        // calculate the in-scattering
        vec3 scattering = calcscatter(costheta) * (1.0 - extinction);
 
        // combine
        vec3 inscatter = incominglight * scattering;
 
        // sun disk
        vec3 sundisk = sundiskparams.z * extinction * pow(clamp(costheta*sundiskparams.x + sundiskparams.y, 0.0, 1.0), 8.0);

        inscatter += sundisk; 
        @(hdrgammaencode inscatter)

        fragcolor = vec4(sunlight * inscatter, atmoalpha);
    }
]

shader 0 "skyfog" [
    attribute vec4 vvertex, vcolor;
    uniform mat4 skymatrix;
    uniform float ldrscale;
    varying vec4 color;
    void main(void)
    {
        gl_Position = skymatrix * vvertex;
        color = vec4(ldrscale * vcolor.rgb, vcolor.a);
    }
] [
    uniform sampler2D tex0;
    varying vec4 color;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = color;
    }
]

lazyshader 0 "tqaaresolve" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    uniform vec4 quincunx;
    varying vec2 texcoord0, texcoord1, texcoord2, texcoord3;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
        texcoord1 = vtexcoord0 + quincunx.xy;
        texcoord2 = vtexcoord0 + quincunx.zw;
        texcoord3 = vtexcoord0 + quincunx.xy - 0.5;
    }
] [
    @(gfetchdefs tex2)
    uniform sampler2DRect tex0, tex1;
    uniform mat4 reprojectmatrix;
    uniform vec3 maxvelocity;
    uniform vec2 colorweight;
    varying vec2 texcoord0, texcoord1, texcoord2, texcoord3;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        @(gdepthunpack depth [gfetch(tex2, texcoord0)] [
            vec4 prevtc = reprojectmatrix * vec4(depth*texcoord0, depth, 1.0);
        ] [
            vec4 prevtc = reprojectmatrix * vec4(texcoord0, depth, 1.0);
        ])
        prevtc.xy /= prevtc.w;
        vec2 vel = prevtc.xy - texcoord0;

        vec4 color = texture2DRect(tex0, texcoord1);
        float vscale = color.a*maxvelocity.x*inversesqrt(dot(vel, vel) + 1e-6);
        vec4 prevcolor = texture2DRect(tex1, texcoord2 + vel*vscale);

        vec3 c0 = texture2DRect(tex0, texcoord3).rgb;
        vec3 c1 = texture2DRectOffset(tex0, texcoord3, ivec2(1, 0)).rgb;
        vec3 c2 = texture2DRectOffset(tex0, texcoord3, ivec2(0, 1)).rgb;
        vec3 c3 = texture2DRectOffset(tex0, texcoord3, ivec2(1, 1)).rgb;
        vec3 cmin = min(min(c0, c1), min(c2, c3));
        vec3 cmax = max(max(c0, c1), max(c2, c3));

        vec3 weight = clamp((colorweight.x*max(prevcolor.rgb - cmax, cmin - prevcolor.rgb) + colorweight.y) / (cmax - cmin + 1e-3), 0.0, 1.0);
        fragcolor.rgb = mix(color.rgb, prevcolor.rgb, 0.5 - 0.5*weight);
        fragcolor.a = color.a;
    }
]

lazyshader 0 "ovrwarp" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0;
    }
] [
    uniform sampler2DRect tex0; 
    uniform vec2 lenscenter;
    uniform vec4 lensscale;
    uniform vec4 distortk;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec2 t = (texcoord0 - lenscenter) * lensscale.xy;
        float r = dot(t, t);
        vec2 tc = lenscenter + lensscale.zw * t * (distortk.x + r*(distortk.y + r*(distortk.z + r*distortk.w)));
        fragcolor = texture2DRect(tex0, tc);
    }
]

smaaopt = [ >= (strstr $smaaopts $arg1) 0 ]
smaashaders = [
    smaapreset = $arg1   
    smaaopts = $arg2
    exec "config/smaa.cfg"
]

fxaaopt = [ >= (strstr $fxaaopts $arg1) 0 ]
fxaashaders = [
    fxaapreset = $arg1
    fxaaopts = $arg2
    exec "config/fxaa.cfg"
]

