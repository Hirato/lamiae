1047,1048c1047,1050
<     if(!isdown) return true;
<     e->key(code, cooked);
---
>     if(isdown)
>       e->key(code, cooked);
>     else
>       e->key(0x40000000+code,0);
1738c1738
< bool sortidents(ident *x, ident *y)
---
> int sortidents(ident *x, ident *y)
370c370
<         draw_char(tex, '_', left+cx, top+cy);
---
>         draw_char(tex, '|', left+cx-8, top+cy-2);
62c62
<             memcpy(text, str, slen + 1);
---
>             memcpy(text, str, slen);
144a145
>     bool bShiftDown; // flag to keep record of whether shift key is down or not
163a165
>         bShiftDown=false;
278,279c280,288
<             else if(y == sy) line += sx;
<             else if(y == ey) len = ex;
---
>             else if(y == sy)
>             {
>                line += sx;
>                len -=sx;
>             }
>             else if(y == ey)
>             {
>                len = ex;
>             }
332c341
<     void del() // removes the current selection (if any)
---
>     bool del() // removes the current selection (if any), returns true if selection was removed
338c347
<             return;
---
>             return false;
347,348c356,367
<             if(ey > sy+2) { removelines(sy+1, ey-(sy+2)); ey = sy+1; }
<             if(ex == lines[ey].len) removelines(ey, 1); else lines[ey].del(0, ex);
---
>             bool bAppendLastLine=false;
>             if(ey > sy+1) { removelines(sy+1, ey-(sy+1)); ey = sy+1; }
>             if(ex == lines[ey].len) 
>             {
>                removelines(ey, 1);                
>             }
>             else 
>             {
>                //if(ex==0) 
>                   bAppendLastLine=true;
>                lines[ey].del(0, ex);
>             }
349a369,374
> 
>             if(bAppendLastLine && sy+1<lines.length())
>             {
>                lines[sy].append(lines[sy+1].text);
>                removelines(sy+1, 1);
>             }
354a380
>         return true;
409a436,437
>                 char *currLine=lines[cy].text;
>                 char *pastingLine=b->lines[i].text;
412c440,443
<                     lines[cy++].append(b->lines[i].text);
---
>                    editline newline(&lines[cy].text[cx]);
>                    lines[cy].chop(cx);
>                    lines[cy].insert(b->lines[i].text,cx);
>                    lines.insert(++cy, newline);
414c445
<                 else if(i >= b->lines.length())
---
>                 else if(i == b->lines.length()-1)
425a457,458
>         int iCursorXBefore=cx;
>         int iCursorYBefore=cy;
436c469
<                 cy--;
---
>                 if(cy>0) cy--;
449a483,513
>             case SDLK_TAB:
>                 {
>                    int sx,sy,ex,ey;
>                    if(region(sx,sy,ex,ey))
>                    {
>                       int lastLine=ex==0?ey:ey+1;
>                       for(int y=sy;y<lastLine;y++)
>                       {
>                          if(bShiftDown)
>                          {
>                             // remove indent
>                             if(lines[y].text[0]=='\t')
>                                lines[y].del(0,1);
>                             else
>                             {
>                                loopi(3)
>                                   if(lines[y].text[0]==' ')
>                                      lines[y].del(0,1);
>                             }
>                          }
>                          else
>                          {
>                             // add indent
>                             lines[y].prepend("   ");
>                          }
>                       }
>                    }
>                    else
>                       insert(cooked);
>                 }
>                 break;
463c527
<                 cx = cy = 0;
---
>                 cx = 0;
466c530
<                 cx = cy = INT_MAX;
---
>                 cx = INT_MAX;
468,469c532,538
<             case SDLK_LEFT:
<                 cx--;
---
>             case SDLK_LEFT:                
>                 if(cx>0) cx--;
>                 else if(cy>0)
>                 {
>                    cy--;
>                    cx=lines[cy].len;
>                 }
472c541,546
<                 cx++;
---
>                 if(cx<lines[cy].len)
>                   cx++;
>                 else if(cy<lines.length()-1)
>                 {
>                    cy++;cx=0;
>                 }
476,482c550,558
<                 del();
<                 editline &current = currentline();
<                 if(cx < current.len) current.del(cx, 1);
<                 else if(cy < lines.length()-1)
<                 {   //combine with next line
<                     current.append(lines[cy+1].text);
<                     removelines(cy+1, 1);
---
>                 if(!del())
>                 {
>                    editline &current = currentline();
>                    if(cx < current.len) current.del(cx, 1);
>                    else if(cy < lines.length()-1)
>                    {   //combine with next line
>                        current.append(lines[cy+1].text);
>                        removelines(cy+1, 1);
>                    }
488,495c564,573
<                 del();
<                 editline &current = currentline();
<                 if(cx > 0) current.del(--cx, 1);
<                 else if(cy > 0)
<                 {   //combine with previous line
<                     cx = lines[cy-1].len;
<                     lines[cy-1].append(current.text);
<                     removelines(cy--, 1);
---
>                 if(!del())
>                 {
>                    editline &current = currentline();
>                    if(cx > 0) current.del(--cx, 1);
>                    else if(cy > 0)
>                    {   //combine with previous line
>                        cx = lines[cy-1].len;
>                        lines[cy-1].append(current.text);
>                        removelines(cy--, 1);
>                    }
500a579,583
>                 bShiftDown=true;
>                 break;
>             case SDLK_LSHIFT+0x40000000:
>             case SDLK_RSHIFT+0x40000000:
>                 bShiftDown=false;
503,504c586,595
<                 cooked = '\n';
<                 // fall through
---
>                 {
>                     // indent next line as current
>                     int indent=0;
>                     editline &current = currentline();
>                     const char *begin=current.text;
>                     while(*begin++==' ') indent++;
>                     insert('\n');
>                     loopi(indent) insert(' ');
>                     break;
>                 }
506c597,600
<                 insert(cooked);
---
>                 if((code&0x40000000)==0)
>                    insert(cooked);
>                 break;
>             case 0:
508a603,629
> 
>         if((code&0x40000000)==0)  // Process only key down events
>         {
>            if(iCursorXBefore!=cx || iCursorYBefore!=cy)  // if the cursor has moved
>            {
>                if(bShiftDown)   // And the shift key is down
>                {
>                   int sx,sy,ex,ey;
>                   region(sx,sy,ex,ey);
>                   if(iCursorXBefore==sx && iCursorYBefore==sy)   // Move the beginning of the selection
>                   {
>                      if(cx>=0) mx=cx;
>                      if(cy>=0) my=cy;              
>                   }
>                   else  // Move the end of the selection (which is the cursor self, so don't do anything)
>                   {
>                      if(mx==-1)
>                      {
>                         mx=iCursorXBefore;
>                         my=iCursorYBefore;
>                      }
>                   }
>                }
>                else  // If the shift key is not down and we move the cursor -> remove selection
>                   mark(false);
>            }
>         }
626a748
>         
